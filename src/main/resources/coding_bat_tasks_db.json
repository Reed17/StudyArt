[
  {
    "groupName": "Warmup-1",
    "title": "sleepIn",
    "description": "The parameter weekday is true if it is a weekday, and the parameter vacation is true if we are on vacation. We sleep in if it is not a weekday or we\u0027re on vacation. Return true if we sleep in. ",
    "examples": "sleepIn(false, false) → true sleepIn(true, false) → false sleepIn(false, true) → true\n",
    "template": "public boolean sleepIn(boolean weekday, boolean vacation) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "boolean",
          "name": "weekday"
        },
        {
          "type": "boolean",
          "name": "vacation"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "false",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "true",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "false",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "true",
            "true"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "monkeyTrouble",
    "description": "We have two monkeys, a and b, and the parameters aSmile and bSmile indicate if each is smiling. We are in trouble if they are both smiling or if neither of them is smiling. Return true if we are in trouble. ",
    "examples": "monkeyTrouble(true, true) → true monkeyTrouble(false, false) → true monkeyTrouble(true, false) → false\n",
    "template": "public boolean monkeyTrouble(boolean aSmile, boolean bSmile) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "boolean",
          "name": "aSmile"
        },
        {
          "type": "boolean",
          "name": "bSmile"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "true",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "false",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "true",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "false",
            "true"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "sumDouble",
    "description": "Given two int values, return their sum. Unless the two values are the same, then return double their sum. ",
    "examples": "sumDouble(1, 2) → 3 sumDouble(3, 2) → 5 sumDouble(2, 2) → 8\n",
    "template": "public int sumDouble(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1",
            "2"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "3",
            "2"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "2",
            "2"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "-1",
            "0"
          ],
          "expectedValue": "-1"
        },
        {
          "inData": [
            "3",
            "3"
          ],
          "expectedValue": "12"
        },
        {
          "inData": [
            "0",
            "0"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "0",
            "1"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "3",
            "4"
          ],
          "expectedValue": "7"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "diff21",
    "description": "Given an int n, return the absolute difference between n and 21, except return double the absolute difference if n is over 21. ",
    "examples": "diff21(19) → 2 diff21(10) → 11 diff21(21) → 0\n",
    "template": "public int diff21(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "19"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "10"
          ],
          "expectedValue": "11"
        },
        {
          "inData": [
            "21"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "22"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "25"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "30"
          ],
          "expectedValue": "18"
        },
        {
          "inData": [
            "0"
          ],
          "expectedValue": "21"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "20"
        },
        {
          "inData": [
            "2"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "-1"
          ],
          "expectedValue": "22"
        },
        {
          "inData": [
            "-2"
          ],
          "expectedValue": "23"
        },
        {
          "inData": [
            "50"
          ],
          "expectedValue": "58"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "parrotTrouble",
    "description": "We have a loud talking parrot. The \"hour\" parameter is the current hour time in the range 0..23. We are in trouble if the parrot is talking and the hour is before 7 or after 20. Return true if we are in trouble. ",
    "examples": "parrotTrouble(true, 6) → true parrotTrouble(true, 7) → false parrotTrouble(false, 6) → false\n",
    "template": "public boolean parrotTrouble(boolean talking, int hour) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "boolean",
          "name": "talking"
        },
        {
          "type": "int",
          "name": "hour"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "true",
            "6"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "true",
            "7"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "false",
            "6"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "true",
            "21"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "false",
            "21"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "false",
            "20"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "true",
            "23"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "false",
            "23"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "true",
            "20"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "false",
            "12"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "makes10",
    "description": "Given 2 ints, a and b, return true if one if them is 10 or if their sum is 10. ",
    "examples": "makes10(9, 10) → true makes10(9, 9) → false makes10(1, 9) → true\n",
    "template": "public boolean makes10(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "9",
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "9",
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1",
            "9"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10",
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "8",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "8",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "10",
            "42"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "12",
            "-2"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "nearHundred",
    "description": "Given an int n, return true if it is within 10 of 100 or 200. Note: Math.abs(num) computes the absolute value of a number. ",
    "examples": "nearHundred(93) → true nearHundred(90) → true nearHundred(89) → false\n",
    "template": "public boolean nearHundred(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "93"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "90"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "89"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "110"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "111"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "121"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "5"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "191"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "189"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "190"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "200"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "210"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "211"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "290"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "posNeg",
    "description": "Given 2 int values, return true if one is negative and one is positive. Except if the parameter \"negative\" is true, then return true only if both are negative. ",
    "examples": "posNeg(1, -1, false) → true posNeg(-1, 1, false) → true posNeg(-4, -5, true) → true\n",
    "template": "public boolean posNeg(int a, int b, boolean negative) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "boolean",
          "name": "negative"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1",
            "-1",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "-1",
            "1",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "-4",
            "-5",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "-4",
            "-5",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "-4",
            "5",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "-4",
            "5",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1",
            "1",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "-1",
            "-1",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1",
            "-1",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "-1",
            "1",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1",
            "1",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "-1",
            "-1",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "5",
            "-5",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "-6",
            "6",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "-5",
            "-6",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "-2",
            "-1",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1",
            "2",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "-5",
            "6",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "-5",
            "-5",
            "true"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "notString",
    "description": "Given a string, return a new string where \"not \" has been added to the front. However, if the string already begins with \"not\", return the string unchanged. Note: use .equals() to compare 2 strings. ",
    "examples": "notString(\"candy\") → \"not candy\" notString(\"x\") → \"not x\" notString(\"not bad\") → \"not bad\"\n",
    "template": "public String notString(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "candy"
          ],
          "expectedValue": "not candy"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "not x"
        },
        {
          "inData": [
            "not bad"
          ],
          "expectedValue": "not bad"
        },
        {
          "inData": [
            "bad"
          ],
          "expectedValue": "not bad"
        },
        {
          "inData": [
            "not"
          ],
          "expectedValue": "not"
        },
        {
          "inData": [
            "is not"
          ],
          "expectedValue": "not is not"
        },
        {
          "inData": [
            "no"
          ],
          "expectedValue": "not no"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "missingChar",
    "description": "Given a non-empty string and an int n, return a new string where the char at index n has been removed. The value of n will be a valid index of a char in the original string (i.e. n will be in the range 0..str.length()-1 inclusive). ",
    "examples": "missingChar(\"kitten\", 1) → \"ktten\" missingChar(\"kitten\", 0) → \"itten\" missingChar(\"kitten\", 4) → \"kittn\"\n",
    "template": "public String missingChar(String str, int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "kitten",
            "1"
          ],
          "expectedValue": "ktten"
        },
        {
          "inData": [
            "kitten",
            "0"
          ],
          "expectedValue": "itten"
        },
        {
          "inData": [
            "kitten",
            "4"
          ],
          "expectedValue": "kittn"
        },
        {
          "inData": [
            "Hi",
            "0"
          ],
          "expectedValue": "i"
        },
        {
          "inData": [
            "Hi",
            "1"
          ],
          "expectedValue": "H"
        },
        {
          "inData": [
            "code",
            "0"
          ],
          "expectedValue": "ode"
        },
        {
          "inData": [
            "code",
            "1"
          ],
          "expectedValue": "cde"
        },
        {
          "inData": [
            "code",
            "2"
          ],
          "expectedValue": "coe"
        },
        {
          "inData": [
            "code",
            "3"
          ],
          "expectedValue": "cod"
        },
        {
          "inData": [
            "chocolate",
            "8"
          ],
          "expectedValue": "chocolat"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "frontBack",
    "description": "Given a string, return a new string where the first and last chars have been exchanged. ",
    "examples": "frontBack(\"code\") → \"eodc\" frontBack(\"a\") → \"a\" frontBack(\"ab\") → \"ba\"\n",
    "template": "public String frontBack(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "code"
          ],
          "expectedValue": "eodc"
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": "a"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "ba"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "cba"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Chocolate"
          ],
          "expectedValue": "ehocolatC"
        },
        {
          "inData": [
            "aavJ"
          ],
          "expectedValue": "Java"
        },
        {
          "inData": [
            "hello"
          ],
          "expectedValue": "oellh"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "front3",
    "description": "Given a string, we\u0027ll say that the front is the first 3 chars of the string. If the string length is less than 3, the front is whatever is there. Return a new string which is 3 copies of the front. ",
    "examples": "front3(\"Java\") → \"JavJavJav\" front3(\"Chocolate\") → \"ChoChoCho\" front3(\"abc\") → \"abcabcabc\"\n",
    "template": "public String front3(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Java"
          ],
          "expectedValue": "JavJavJav"
        },
        {
          "inData": [
            "Chocolate"
          ],
          "expectedValue": "ChoChoCho"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "abcabcabc"
        },
        {
          "inData": [
            "abcXYZ"
          ],
          "expectedValue": "abcabcabc"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "ababab"
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": "aaa"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "backAround",
    "description": "Given a string, take the last char and return a new string with the last char added at the front and back, so \"cat\" yields \"tcatt\". The original string will be length 1 or more. ",
    "examples": "backAround(\"cat\") → \"tcatt\" backAround(\"Hello\") → \"oHelloo\" backAround(\"a\") → \"aaa\"\n",
    "template": "public String backAround(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "cat"
          ],
          "expectedValue": "tcatt"
        },
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "oHelloo"
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": "aaa"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "cabcc"
        },
        {
          "inData": [
            "read"
          ],
          "expectedValue": "dreadd"
        },
        {
          "inData": [
            "boo"
          ],
          "expectedValue": "obooo"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "or35",
    "description": "Return true if the given non-negative number is a multiple of 3 or a multiple of 5. Use the % \"mod\" operator -- see \u003ca href\u003d\"/doc/practice/mod-introduction.html\"\u003eIntroduction to Mod\u003c/a\u003e ",
    "examples": "or35(3) → true or35(10) → true or35(8) → false\n",
    "template": "public boolean or35(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "3"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "8"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "15"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "5"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "9"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "4"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "7"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "6"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "17"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "18"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "29"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "20"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "21"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "22"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "45"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "99"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "100"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "101"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "121"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "122"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "123"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "front22",
    "description": "Given a string, take the first 2 chars and return the string with the 2 chars added at both the front and back, so \"kitten\" yields\"kikittenki\". If the string length is less than 2, use whatever chars are there. ",
    "examples": "front22(\"kitten\") → \"kikittenki\" front22(\"Ha\") → \"HaHaHa\" front22(\"abc\") → \"ababcab\"\n",
    "template": "public String front22(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "kitten"
          ],
          "expectedValue": "kikittenki"
        },
        {
          "inData": [
            "Ha"
          ],
          "expectedValue": "HaHaHa"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "ababcab"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "ababab"
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": "aaa"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Logic"
          ],
          "expectedValue": "LoLogicLo"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "startHi",
    "description": "Given a string, return true if the string starts with \"hi\" and false otherwise. ",
    "examples": "startHi(\"hi there\") → true startHi(\"hi\") → true startHi(\"hello hi\") → false\n",
    "template": "public boolean startHi(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "hi there"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "hi"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "hello hi"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "he"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "h"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "ho hi"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "hi ho"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "icyHot",
    "description": "Given two temperatures, return true if one is less than 0 and the other is greater than 100. ",
    "examples": "icyHot(120, -1) → true icyHot(-1, 120) → true icyHot(2, 120) → false\n",
    "template": "public boolean icyHot(int temp1, int temp2) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "temp1"
        },
        {
          "type": "int",
          "name": "temp2"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "120",
            "-1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "-1",
            "120"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "2",
            "120"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "-1",
            "100"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "-2",
            "-2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "120",
            "120"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "in1020",
    "description": "Given 2 int values, return true if either of them is in the range 10..20 inclusive. ",
    "examples": "in1020(12, 99) → true in1020(21, 12) → true in1020(8, 99) → false\n",
    "template": "public boolean in1020(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "12",
            "99"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "21",
            "12"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "8",
            "99"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "99",
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "20",
            "20"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "21",
            "21"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "9",
            "9"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "hasTeen",
    "description": "We\u0027ll say that a number is \"teen\" if it is in the range 13..19 inclusive. Given 3 int values, return true if 1 or more of them are teen. ",
    "examples": "hasTeen(13, 20, 10) → true hasTeen(20, 19, 10) → true hasTeen(20, 10, 13) → true\n",
    "template": "public boolean hasTeen(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "13",
            "20",
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "20",
            "19",
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "20",
            "10",
            "13"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "20",
            "12"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "19",
            "20",
            "12"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "12",
            "20",
            "19"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "12",
            "9",
            "20"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "12",
            "18",
            "20"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "14",
            "2",
            "20"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "4",
            "2",
            "20"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "11",
            "22",
            "22"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "loneTeen",
    "description": "We\u0027ll say that a number is \"teen\" if it is in the range 13..19 inclusive. Given 2 int values, return true if one or the other is teen, but not both. ",
    "examples": "loneTeen(13, 99) → true loneTeen(21, 19) → true loneTeen(13, 13) → false\n",
    "template": "public boolean loneTeen(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "13",
            "99"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "21",
            "19"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "13",
            "13"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "14",
            "20"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "20",
            "15"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "16",
            "17"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "16",
            "9"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "16",
            "18"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "13",
            "19"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "13",
            "20"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "6",
            "18"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "99",
            "13"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "99",
            "99"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "delDel",
    "description": "Given a string, if the string \"del\" appears starting at index 1, return a string where that \"del\" has been deleted. Otherwise, return the string unchanged. ",
    "examples": "delDel(\"adelbc\") → \"abc\" delDel(\"adelHello\") → \"aHello\" delDel(\"adedbc\") → \"adedbc\"\n",
    "template": "public String delDel(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "adelbc"
          ],
          "expectedValue": "abc"
        },
        {
          "inData": [
            "adelHello"
          ],
          "expectedValue": "aHello"
        },
        {
          "inData": [
            "adedbc"
          ],
          "expectedValue": "adedbc"
        },
        {
          "inData": [
            "abcdel"
          ],
          "expectedValue": "abcdel"
        },
        {
          "inData": [
            "add"
          ],
          "expectedValue": "add"
        },
        {
          "inData": [
            "ad"
          ],
          "expectedValue": "ad"
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": "a"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "del"
          ],
          "expectedValue": "del"
        },
        {
          "inData": [
            "adel"
          ],
          "expectedValue": "a"
        },
        {
          "inData": [
            "aadelbb"
          ],
          "expectedValue": "aadelbb"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "mixStart",
    "description": "Return true if the given string begins with \"mix\", except the \u0027m\u0027 can be anything, so \"pix\", \"9ix\" .. all count. ",
    "examples": "mixStart(\"mix snacks\") → true mixStart(\"pix snacks\") → true mixStart(\"piz snacks\") → false\n",
    "template": "public boolean mixStart(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "mix snacks"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "pix snacks"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "piz snacks"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "nix"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "ni"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "n"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "startOz",
    "description": "Given a string, return a string made of the first 2 chars (if present), however include first char only if it is \u0027o\u0027 and include the second only if it is \u0027z\u0027, so \"ozymandias\" yields \"oz\". ",
    "examples": "startOz(\"ozymandias\") → \"oz\" startOz(\"bzoo\") → \"z\" startOz(\"oxx\") → \"o\"\n",
    "template": "public String startOz(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "ozymandias"
          ],
          "expectedValue": "oz"
        },
        {
          "inData": [
            "bzoo"
          ],
          "expectedValue": "z"
        },
        {
          "inData": [
            "oxx"
          ],
          "expectedValue": "o"
        },
        {
          "inData": [
            "oz"
          ],
          "expectedValue": "oz"
        },
        {
          "inData": [
            "ounce"
          ],
          "expectedValue": "o"
        },
        {
          "inData": [
            "o"
          ],
          "expectedValue": "o"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "zoo"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "aztec"
          ],
          "expectedValue": "z"
        },
        {
          "inData": [
            "zzzz"
          ],
          "expectedValue": "z"
        },
        {
          "inData": [
            "oznic"
          ],
          "expectedValue": "oz"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "intMax",
    "description": "Given three int values, a b c, return the largest. ",
    "examples": "intMax(1, 2, 3) → 3 intMax(1, 3, 2) → 3 intMax(3, 2, 1) → 3\n",
    "template": "public int intMax(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1",
            "2",
            "3"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "1",
            "3",
            "2"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "3",
            "2",
            "1"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "9",
            "3",
            "3"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "3",
            "9",
            "3"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "3",
            "3",
            "9"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "8",
            "2",
            "3"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "-3",
            "-1",
            "-2"
          ],
          "expectedValue": "-1"
        },
        {
          "inData": [
            "6",
            "2",
            "5"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "5",
            "6",
            "2"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "5",
            "2",
            "6"
          ],
          "expectedValue": "6"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "close10",
    "description": "Given 2 int values, return whichever value is nearest to the value 10, or return 0 in the event of a tie. Note that Math.abs(n) returns the absolute value of a number. ",
    "examples": "close10(8, 13) → 8 close10(13, 8) → 8 close10(13, 7) → 0\n",
    "template": "public int close10(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "8",
            "13"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "13",
            "8"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "13",
            "7"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "7",
            "13"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "9",
            "13"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "13",
            "8"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "10",
            "12"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "11",
            "10"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "5",
            "21"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "0",
            "20"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "10",
            "10"
          ],
          "expectedValue": "0"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "in3050",
    "description": "Given 2 int values, return true if they are both in the range 30..40 inclusive, or they are both in the range 40..50 inclusive. ",
    "examples": "in3050(30, 31) → true in3050(30, 41) → false in3050(40, 50) → true\n",
    "template": "public boolean in3050(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "30",
            "31"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "30",
            "41"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "40",
            "50"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "40",
            "51"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "39",
            "50"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "50",
            "39"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "40",
            "39"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "49",
            "48"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "50",
            "40"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "50",
            "51"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "35",
            "36"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "35",
            "45"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "max1020",
    "description": "Given 2 positive int values, return the larger value that is in the range 10..20 inclusive, or return 0 if neither is in that range. ",
    "examples": "max1020(11, 19) → 19 max1020(19, 11) → 19 max1020(11, 9) → 11\n",
    "template": "public int max1020(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "11",
            "19"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "19",
            "11"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "11",
            "9"
          ],
          "expectedValue": "11"
        },
        {
          "inData": [
            "9",
            "21"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "10",
            "21"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "21",
            "10"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "9",
            "11"
          ],
          "expectedValue": "11"
        },
        {
          "inData": [
            "23",
            "10"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "20",
            "10"
          ],
          "expectedValue": "20"
        },
        {
          "inData": [
            "7",
            "20"
          ],
          "expectedValue": "20"
        },
        {
          "inData": [
            "17",
            "16"
          ],
          "expectedValue": "17"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "stringE",
    "description": "Return true if the given string contains between 1 and 3 \u0027e\u0027 chars. ",
    "examples": "stringE(\"Hello\") → true stringE(\"Heelle\") → true stringE(\"Heelele\") → false\n",
    "template": "public boolean stringE(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "Heelle"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "Heelele"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "Hll"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "e"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "lastDigit",
    "description": "Given two non-negative int values, return true if they have the same last digit, such as with 27 and 57. Note that the % \"mod\" operator computes remainders, so 17 % 10 is 7. ",
    "examples": "lastDigit(7, 17) → true lastDigit(6, 17) → false lastDigit(3, 113) → true\n",
    "template": "public boolean lastDigit(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "7",
            "17"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "6",
            "17"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "3",
            "113"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "114",
            "113"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "114",
            "4"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "11",
            "0"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "endUp",
    "description": "Given a string, return a new string where the last 3 chars are now in upper case. If the string has less than 3 chars, uppercase whatever is there. Note that str.toUpperCase() returns the uppercase version of a string. ",
    "examples": "endUp(\"Hello\") → \"HeLLO\" endUp(\"hi there\") → \"hi thERE\" endUp(\"hi\") → \"HI\"\n",
    "template": "public String endUp(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "HeLLO"
        },
        {
          "inData": [
            "hi there"
          ],
          "expectedValue": "hi thERE"
        },
        {
          "inData": [
            "hi"
          ],
          "expectedValue": "HI"
        },
        {
          "inData": [
            "woo hoo"
          ],
          "expectedValue": "woo HOO"
        },
        {
          "inData": [
            "xyz12"
          ],
          "expectedValue": "xyZ12"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "X"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        }
      ]
    }
  },
  {
    "groupName": "Warmup-1",
    "title": "everyNth",
    "description": "Given a non-empty string and an int N, return the string made starting with char 0, and then every Nth char of the string. So if N is 3, use char 0, 3, 6, ... and so on. N is 1 or more. ",
    "examples": "everyNth(\"Miracle\", 2) → \"Mrce\" everyNth(\"abcdefg\", 2) → \"aceg\" everyNth(\"abcdefg\", 3) → \"adg\"\n",
    "template": "public String everyNth(String str, int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Miracle",
            "2"
          ],
          "expectedValue": "Mrce"
        },
        {
          "inData": [
            "abcdefg",
            "2"
          ],
          "expectedValue": "aceg"
        },
        {
          "inData": [
            "abcdefg",
            "3"
          ],
          "expectedValue": "adg"
        },
        {
          "inData": [
            "Chocolate",
            "3"
          ],
          "expectedValue": "Cca"
        },
        {
          "inData": [
            "Chocolates",
            "3"
          ],
          "expectedValue": "Ccas"
        },
        {
          "inData": [
            "Chocolates",
            "4"
          ],
          "expectedValue": "Coe"
        },
        {
          "inData": [
            "Chocolates",
            "100"
          ],
          "expectedValue": "C"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "stringTimes",
    "description": "Given a string and a non-negative int n, return a larger string that is n copies of the original string. ",
    "examples": "stringTimes(\"Hi\", 2) → \"HiHi\" stringTimes(\"Hi\", 3) → \"HiHiHi\" stringTimes(\"Hi\", 1) → \"Hi\"\n",
    "template": "public String stringTimes(String str, int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hi",
            "2"
          ],
          "expectedValue": "HiHi"
        },
        {
          "inData": [
            "Hi",
            "3"
          ],
          "expectedValue": "HiHiHi"
        },
        {
          "inData": [
            "Hi",
            "1"
          ],
          "expectedValue": "Hi"
        },
        {
          "inData": [
            "Hi",
            "0"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Hi",
            "5"
          ],
          "expectedValue": "HiHiHiHiHi"
        },
        {
          "inData": [
            "Oh Boy!",
            "2"
          ],
          "expectedValue": "Oh Boy!Oh Boy!"
        },
        {
          "inData": [
            "x",
            "4"
          ],
          "expectedValue": "xxxx"
        },
        {
          "inData": [
            "",
            "4"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "code",
            "2"
          ],
          "expectedValue": "codecode"
        },
        {
          "inData": [
            "code",
            "3"
          ],
          "expectedValue": "codecodecode"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "frontTimes",
    "description": "Given a string and a non-negative int n, we\u0027ll say that the front of the string is the first 3 chars, or whatever is there if the string is less than length 3. Return n copies of the front; ",
    "examples": "frontTimes(\"Chocolate\", 2) → \"ChoCho\" frontTimes(\"Chocolate\", 3) → \"ChoChoCho\" frontTimes(\"Abc\", 3) → \"AbcAbcAbc\"\n",
    "template": "public String frontTimes(String str, int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Chocolate",
            "2"
          ],
          "expectedValue": "ChoCho"
        },
        {
          "inData": [
            "Chocolate",
            "3"
          ],
          "expectedValue": "ChoChoCho"
        },
        {
          "inData": [
            "Abc",
            "3"
          ],
          "expectedValue": "AbcAbcAbc"
        },
        {
          "inData": [
            "Ab",
            "4"
          ],
          "expectedValue": "AbAbAbAb"
        },
        {
          "inData": [
            "A",
            "4"
          ],
          "expectedValue": "AAAA"
        },
        {
          "inData": [
            "",
            "4"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Abc",
            "0"
          ],
          "expectedValue": ""
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "countXX",
    "description": "Count the number of \"xx\" in the given string. We\u0027ll say that overlapping is allowed, so \"xxx\" contains 2 \"xx\". ",
    "examples": "countXX(\"abcxx\") → 1 countXX(\"xxx\") → 2 countXX(\"xxxx\") → 3\n",
    "template": "int countXX(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abcxx"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "xxx"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "xxxx"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "Hello there"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "Hexxo thxxe"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "Kittens"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "Kittensxxx"
          ],
          "expectedValue": "2"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "doubleX",
    "description": "Given a string, return true if the first instance of \"x\" in the string is immediately followed by another \"x\". ",
    "examples": "doubleX(\"axxbb\") → true doubleX(\"axaxax\") → false doubleX(\"xxxxx\") → true\n",
    "template": "boolean doubleX(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "axxbb"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "axaxax"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xxxxx"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xaxxx"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "aaaax"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xx"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xax"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xaxx"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "stringBits",
    "description": "Given a string, return a new string made of every other char starting with the first, so \"Hello\" yields \"Hlo\". ",
    "examples": "stringBits(\"Hello\") → \"Hlo\" stringBits(\"Hi\") → \"H\" stringBits(\"Heeololeo\") → \"Hello\"\n",
    "template": "public String stringBits(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "Hlo"
        },
        {
          "inData": [
            "Hi"
          ],
          "expectedValue": "H"
        },
        {
          "inData": [
            "Heeololeo"
          ],
          "expectedValue": "Hello"
        },
        {
          "inData": [
            "HiHiHi"
          ],
          "expectedValue": "HHH"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Greetings"
          ],
          "expectedValue": "Getns"
        },
        {
          "inData": [
            "Chocoate"
          ],
          "expectedValue": "Coot"
        },
        {
          "inData": [
            "pi"
          ],
          "expectedValue": "p"
        },
        {
          "inData": [
            "Hello Kitten"
          ],
          "expectedValue": "HloKte"
        },
        {
          "inData": [
            "hxaxpxpxy"
          ],
          "expectedValue": "happy"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "stringSplosion",
    "description": "Given a non-empty string like \"Code\" return a string like \"CCoCodCode\". ",
    "examples": "stringSplosion(\"Code\") → \"CCoCodCode\" stringSplosion(\"abc\") → \"aababc\" stringSplosion(\"ab\") → \"aab\"\n",
    "template": "public String stringSplosion(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Code"
          ],
          "expectedValue": "CCoCodCode"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "aababc"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "aab"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "x"
        },
        {
          "inData": [
            "fade"
          ],
          "expectedValue": "ffafadfade"
        },
        {
          "inData": [
            "There"
          ],
          "expectedValue": "TThTheTherThere"
        },
        {
          "inData": [
            "Kitten"
          ],
          "expectedValue": "KKiKitKittKitteKitten"
        },
        {
          "inData": [
            "Bye"
          ],
          "expectedValue": "BByBye"
        },
        {
          "inData": [
            "Good"
          ],
          "expectedValue": "GGoGooGood"
        },
        {
          "inData": [
            "Bad"
          ],
          "expectedValue": "BBaBad"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "last2",
    "description": "Given a string, return the count of the number of times that a substring length 2 appears in the string and also as the last 2 chars of the string, so \"hixxxhi\" yields 1 (we won\u0027t count the end substring). ",
    "examples": "last2(\"hixxhi\") → 1 last2(\"xaxxaxaxx\") → 1 last2(\"axxxaaxx\") → 2\n",
    "template": "public int last2(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "hixxhi"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "xaxxaxaxx"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "axxxaaxx"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "xxaxxaxxaxx"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "xaxaxaxx"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "xxxx"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "13121312"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "11212"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "13121311"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "1717171"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "hi"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "h"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "arrayCount9",
    "description": "Given an array of ints, return the number of 9\u0027s in the array. ",
    "examples": "arrayCount9({1, 2, 9}) → 1 arrayCount9({1, 9, 9}) → 2 arrayCount9({1, 9, 9, 3, 9}) → 3\n",
    "template": "public int arrayCount9(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 9}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{1, 9, 9}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 9, 9, 3, 9}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{4, 2, 4, 3, 1}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{9, 2, 4, 3, 1}"
          ],
          "expectedValue": "1"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "arrayFront9",
    "description": "Given an array of ints, return true if one of the first 4 elements in the array is a 9. The array length may be less than 4. ",
    "examples": "arrayFront9({1, 2, 9, 3, 4}) → true arrayFront9({1, 2, 3, 4, 9}) → false arrayFront9({1, 2, 3, 4, 5}) → false\n",
    "template": "public boolean arrayFront9(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 9, 3, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 9}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{9, 2, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 9, 9}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 9}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{5, 5}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{9}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 9, 2, 3, 3}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "array123",
    "description": "Given an array of ints, return true if .. 1, 2, 3, .. appears in the array somewhere. ",
    "examples": "array123({1, 1, 2, 3, 1}) → true array123({1, 1, 2, 4, 1}) → false array123({1, 1, 2, 1, 2, 3}) → true\n",
    "template": "public boolean array123(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 1, 2, 3, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 2, 4, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1, 2, 1, 2, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 2, 1, 2, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3, 1, 2, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "stringMatch",
    "description": "Given 2 strings, a and b, return the number of the positions where they contain the same length 2 substring. So \"xxcaazz\" and \"xxbaaz\" yields 3, since the \"xx\", \"aa\", and \"az\" substrings appear in the same place in both strings. ",
    "examples": "stringMatch(\"xxcaazz\", \"xxbaaz\") → 3 stringMatch(\"abc\", \"abc\") → 2 stringMatch(\"abc\", \"axc\") → 0\n",
    "template": "public int stringMatch(String a, String b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "a"
        },
        {
          "type": "String",
          "name": "b"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "xxcaazz",
            "xxbaaz"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "abc",
            "abc"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "abc",
            "axc"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "hello",
            "he"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "he",
            "hello"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "h",
            "hello"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "",
            "hello"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "aabbccdd",
            "abbbxxd"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "aaxxaaxx",
            "iaxxai"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "iaxxai",
            "aaxxaaxx"
          ],
          "expectedValue": "3"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "stringX",
    "description": "Given a string, return a version where all the \"x\" have been removed. Except an \"x\" at the very start or end should not be removed. ",
    "examples": "stringX(\"xxHxix\") → \"xHix\" stringX(\"abxxxcd\") → \"abcd\" stringX(\"xabxxxcdx\") → \"xabcdx\"\n",
    "template": "public String stringX(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "xxHxix"
          ],
          "expectedValue": "xHix"
        },
        {
          "inData": [
            "abxxxcd"
          ],
          "expectedValue": "abcd"
        },
        {
          "inData": [
            "xabxxxcdx"
          ],
          "expectedValue": "xabcdx"
        },
        {
          "inData": [
            "xKittenx"
          ],
          "expectedValue": "xKittenx"
        },
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "Hello"
        },
        {
          "inData": [
            "xx"
          ],
          "expectedValue": "xx"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "x"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "altPairs",
    "description": "Given a string, return a string made of the chars at indexes 0,1, 4,5, 8,9 ... so \"kittens\" yields \"kien\". ",
    "examples": "altPairs(\"kitten\") → \"kien\" altPairs(\"Chocolate\") → \"Chole\" altPairs(\"CodingHorror\") → \"Congrr\"\n",
    "template": "public String altPairs(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "kitten"
          ],
          "expectedValue": "kien"
        },
        {
          "inData": [
            "Chocolate"
          ],
          "expectedValue": "Chole"
        },
        {
          "inData": [
            "CodingHorror"
          ],
          "expectedValue": "Congrr"
        },
        {
          "inData": [
            "yak"
          ],
          "expectedValue": "ya"
        },
        {
          "inData": [
            "ya"
          ],
          "expectedValue": "ya"
        },
        {
          "inData": [
            "y"
          ],
          "expectedValue": "y"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "ThisThatTheOther"
          ],
          "expectedValue": "ThThThth"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "stringYak",
    "description": "Suppose the string \"yak\" is unlucky. Given a string, return a version where all the \"yak\" are removed, but the \"a\" can be any char. The \"yak\" strings will not overlap. ",
    "examples": "stringYak(\"yakpak\") → \"pak\" stringYak(\"pakyak\") → \"pak\" stringYak(\"yak123ya\") → \"123ya\"\n",
    "template": "public String stringYak(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "yakpak"
          ],
          "expectedValue": "pak"
        },
        {
          "inData": [
            "pakyak"
          ],
          "expectedValue": "pak"
        },
        {
          "inData": [
            "yak123ya"
          ],
          "expectedValue": "123ya"
        },
        {
          "inData": [
            "yak"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "yakxxxyak"
          ],
          "expectedValue": "xxx"
        },
        {
          "inData": [
            "HiyakHi"
          ],
          "expectedValue": "HiHi"
        },
        {
          "inData": [
            "xxxyakyyyakzzz"
          ],
          "expectedValue": "xxxyyzzz"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "array667",
    "description": "Given an array of ints, return the number of times that two 6\u0027s are next to each other in the array. Also count instances where the second \"6\" is actually a 7. ",
    "examples": "array667({6, 6, 2}) → 1 array667({6, 6, 2, 6}) → 1 array667({6, 7, 2, 6}) → 1\n",
    "template": "public int array667(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{6, 6, 2}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{6, 6, 2, 6}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{6, 7, 2, 6}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{6, 6, 2, 6, 7}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 6, 3}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{6, 1}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{3, 6, 7, 6}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{3, 6, 6, 7}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{6, 3, 6, 6}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{6, 7, 6, 6}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 2, 3, 5, 6}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{1, 2, 3, 6, 6}"
          ],
          "expectedValue": "1"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "noTriples",
    "description": "Given an array of ints, we\u0027ll say that a triple is a value appearing 3 times in a row in the array. Return true if the array does not contain any triples. ",
    "examples": "noTriples({1, 1, 2, 2, 1}) → true noTriples({1, 1, 2, 2, 2, 1}) → false noTriples({1, 1, 1, 2, 2, 2, 1}) → false\n",
    "template": "public boolean noTriples(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 1, 2, 2, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 2, 2, 2, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1, 1, 2, 2, 2, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1, 2, 2, 1, 2, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Warmup-2",
    "title": "has271",
    "description": "Given an array of ints, return true if it contains a 2, 7, 1 pattern -- a value, followed by the value plus 5, followed by the value minus 1. Additionally the 271 counts even if the \"1\" differs by 2 or less from the correct value. ",
    "examples": "has271({1, 2, 7, 1}) → true has271({1, 2, 8, 1}) → false has271({2, 7, 1}) → true\n",
    "template": "public boolean has271(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 7, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 8, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 7, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 8, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 7, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 7, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 7, -1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 7, -2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{4, 5, 3, 8, 0}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 7, 5, 10, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 7, -2, 4, 9, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 7, 5, 10, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 7, -2, 4, 10, 2}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "helloName",
    "description": "Given a string name, e.g. \"Bob\", return a greeting of the form \"Hello Bob!\". ",
    "examples": "helloName(\"Bob\") → \"Hello Bob!\" helloName(\"Alice\") → \"Hello Alice!\" helloName(\"X\") → \"Hello X!\"\n",
    "template": "public String helloName(String name) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "name"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Bob"
          ],
          "expectedValue": "Hello Bob!"
        },
        {
          "inData": [
            "Alice"
          ],
          "expectedValue": "Hello Alice!"
        },
        {
          "inData": [
            "X"
          ],
          "expectedValue": "Hello X!"
        },
        {
          "inData": [
            "Dolly"
          ],
          "expectedValue": "Hello Dolly!"
        },
        {
          "inData": [
            "Alpha"
          ],
          "expectedValue": "Hello Alpha!"
        },
        {
          "inData": [
            "Omega"
          ],
          "expectedValue": "Hello Omega!"
        },
        {
          "inData": [
            "Goodbye"
          ],
          "expectedValue": "Hello Goodbye!"
        },
        {
          "inData": [
            "ho ho ho"
          ],
          "expectedValue": "Hello ho ho ho!"
        },
        {
          "inData": [
            "xyz!"
          ],
          "expectedValue": "Hello xyz!!"
        },
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "Hello Hello!"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "makeAbba",
    "description": "Given two strings, a and b, return the result of putting them together in the order abba, e.g. \"Hi\" and \"Bye\" returns \"HiByeByeHi\". ",
    "examples": "makeAbba(\"Hi\", \"Bye\") → \"HiByeByeHi\" makeAbba(\"Yo\", \"Alice\") → \"YoAliceAliceYo\" makeAbba(\"What\", \"Up\") → \"WhatUpUpWhat\"\n",
    "template": "public String makeAbba(String a, String b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "a"
        },
        {
          "type": "String",
          "name": "b"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hi",
            "Bye"
          ],
          "expectedValue": "HiByeByeHi"
        },
        {
          "inData": [
            "Yo",
            "Alice"
          ],
          "expectedValue": "YoAliceAliceYo"
        },
        {
          "inData": [
            "What",
            "Up"
          ],
          "expectedValue": "WhatUpUpWhat"
        },
        {
          "inData": [
            "aaa",
            "bbb"
          ],
          "expectedValue": "aaabbbbbbaaa"
        },
        {
          "inData": [
            "x",
            "y"
          ],
          "expectedValue": "xyyx"
        },
        {
          "inData": [
            "x",
            ""
          ],
          "expectedValue": "xx"
        },
        {
          "inData": [
            "",
            "y"
          ],
          "expectedValue": "yy"
        },
        {
          "inData": [
            "Bo",
            "Ya"
          ],
          "expectedValue": "BoYaYaBo"
        },
        {
          "inData": [
            "Ya",
            "Ya"
          ],
          "expectedValue": "YaYaYaYa"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "makeTags",
    "description": "The web is built with HTML strings like \"\u0026lt;i\u0026gt;Yay\u0026lt;/i\u0026gt;\" which draws Yay as italic text. In this example, the \"i\" tag makes \u0026lt;i\u0026gt; and \u0026lt;/i\u0026gt; which surround the word \"Yay\". Given tag and word strings, create the HTML string with tags around the word, e.g. \"\u0026lt;i\u0026gt;Yay\u0026lt;/i\u0026gt;\". ",
    "examples": "makeTags(\"i\", \"Yay\") → \"\u003ci\u003eYay\u003c/i\u003e\" makeTags(\"i\", \"Hello\") → \"\u003ci\u003eHello\u003c/i\u003e\" makeTags(\"cite\", \"Yay\") → \"\u003ccite\u003eYay\u003c/cite\u003e\"\n",
    "template": "public String makeTags(String tag, String word) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "tag"
        },
        {
          "type": "String",
          "name": "word"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "i",
            "Yay"
          ],
          "expectedValue": "\u0026lt;i\u0026gt;Yay\u0026lt;/i\u0026gt;"
        },
        {
          "inData": [
            "i",
            "Hello"
          ],
          "expectedValue": "\u0026lt;i\u0026gt;Hello\u0026lt;/i\u0026gt;"
        },
        {
          "inData": [
            "cite",
            "Yay"
          ],
          "expectedValue": "\u0026lt;cite\u0026gt;Yay\u0026lt;/cite\u0026gt;"
        },
        {
          "inData": [
            "address",
            "here"
          ],
          "expectedValue": "\u0026lt;address\u0026gt;here\u0026lt;/address\u0026gt;"
        },
        {
          "inData": [
            "body",
            "Heart"
          ],
          "expectedValue": "\u0026lt;body\u0026gt;Heart\u0026lt;/body\u0026gt;"
        },
        {
          "inData": [
            "i",
            "i"
          ],
          "expectedValue": "\u0026lt;i\u0026gt;i\u0026lt;/i\u0026gt;"
        },
        {
          "inData": [
            "i",
            ""
          ],
          "expectedValue": "\u0026lt;i\u0026gt;\u0026lt;/i\u0026gt;"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "makeOutWord",
    "description": "Given an \"out\" string length 4, such as \"\u0026lt;\u0026lt;\u0026gt;\u0026gt;\", and a word, return a new string where the word is in the middle of the out string, e.g. \"\u0026lt;\u0026lt;word\u0026gt;\u0026gt;\". Note: use str.substring(i, j) to extract the String starting at index i and going up to but not including index j. ",
    "examples": "makeOutWord(\"\u003c\u003c\u003e\u003e\", \"Yay\") → \"\u003c\u003cYay\u003e\u003e\" makeOutWord(\"\u003c\u003c\u003e\u003e\", \"WooHoo\") → \"\u003c\u003cWooHoo\u003e\u003e\" makeOutWord(\"[[]]\", \"word\") → \"[[word]]\"\n",
    "template": "public String makeOutWord(String out, String word) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "out"
        },
        {
          "type": "String",
          "name": "word"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "\u0026lt;\u0026lt;\u0026gt;\u0026gt;",
            "Yay"
          ],
          "expectedValue": "\u0026lt;\u0026lt;Yay\u0026gt;\u0026gt;"
        },
        {
          "inData": [
            "\u0026lt;\u0026lt;\u0026gt;\u0026gt;",
            "WooHoo"
          ],
          "expectedValue": "\u0026lt;\u0026lt;WooHoo\u0026gt;\u0026gt;"
        },
        {
          "inData": [
            "[[]]",
            "word"
          ],
          "expectedValue": "[[word]]"
        },
        {
          "inData": [
            "HHoo",
            "Hello"
          ],
          "expectedValue": "HHHellooo"
        },
        {
          "inData": [
            "abyz",
            "YAY"
          ],
          "expectedValue": "abYAYyz"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "extraEnd",
    "description": "Given a string, return a new string made of 3 copies of the last 2 chars of the original string. The string length will be at least 2. ",
    "examples": "extraEnd(\"Hello\") → \"lololo\" extraEnd(\"ab\") → \"ababab\" extraEnd(\"Hi\") → \"HiHiHi\"\n",
    "template": "public String extraEnd(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "lololo"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "ababab"
        },
        {
          "inData": [
            "Hi"
          ],
          "expectedValue": "HiHiHi"
        },
        {
          "inData": [
            "Candy"
          ],
          "expectedValue": "dydydy"
        },
        {
          "inData": [
            "Code"
          ],
          "expectedValue": "dedede"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "firstTwo",
    "description": "Given a string, return the string made of its first two chars, so the String \"Hello\" yields \"He\". If the string is shorter than length 2, return whatever there is, so \"X\" yields \"X\", and the empty string \"\" yields the empty string \"\". Note that str.length() returns the length of a string. ",
    "examples": "firstTwo(\"Hello\") → \"He\" firstTwo(\"abcdefg\") → \"ab\" firstTwo(\"ab\") → \"ab\"\n",
    "template": "public String firstTwo(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "He"
        },
        {
          "inData": [
            "abcdefg"
          ],
          "expectedValue": "ab"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "ab"
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": "a"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Kitten"
          ],
          "expectedValue": "Ki"
        },
        {
          "inData": [
            "hi"
          ],
          "expectedValue": "hi"
        },
        {
          "inData": [
            "hiya"
          ],
          "expectedValue": "hi"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "firstHalf",
    "description": "Given a string of even length, return the first half. So the string \"WooHoo\" yields \"Woo\". ",
    "examples": "firstHalf(\"WooHoo\") → \"Woo\" firstHalf(\"HelloThere\") → \"Hello\" firstHalf(\"abcdef\") → \"abc\"\n",
    "template": "public String firstHalf(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "WooHoo"
          ],
          "expectedValue": "Woo"
        },
        {
          "inData": [
            "HelloThere"
          ],
          "expectedValue": "Hello"
        },
        {
          "inData": [
            "abcdef"
          ],
          "expectedValue": "abc"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "a"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "0123456789"
          ],
          "expectedValue": "01234"
        },
        {
          "inData": [
            "kitten"
          ],
          "expectedValue": "kit"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "withoutEnd",
    "description": "Given a string, return a version without the first and last char, so \"Hello\" yields \"ell\". The string length will be at least 2. ",
    "examples": "withoutEnd(\"Hello\") → \"ell\" withoutEnd(\"java\") → \"av\" withoutEnd(\"coding\") → \"odin\"\n",
    "template": "public String withoutEnd(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "ell"
        },
        {
          "inData": [
            "java"
          ],
          "expectedValue": "av"
        },
        {
          "inData": [
            "coding"
          ],
          "expectedValue": "odin"
        },
        {
          "inData": [
            "code"
          ],
          "expectedValue": "od"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Chocolate!"
          ],
          "expectedValue": "hocolate"
        },
        {
          "inData": [
            "kitten"
          ],
          "expectedValue": "itte"
        },
        {
          "inData": [
            "woohoo"
          ],
          "expectedValue": "ooho"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "comboString",
    "description": "Given 2 strings, a and b, return a string of the form short+long+short, with the shorter string on the outside and the longer string on the inside. The strings will not be the same length, but they may be empty (length 0). ",
    "examples": "comboString(\"Hello\", \"hi\") → \"hiHellohi\" comboString(\"hi\", \"Hello\") → \"hiHellohi\" comboString(\"aaa\", \"b\") → \"baaab\"\n",
    "template": "public String comboString(String a, String b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "a"
        },
        {
          "type": "String",
          "name": "b"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello",
            "hi"
          ],
          "expectedValue": "hiHellohi"
        },
        {
          "inData": [
            "hi",
            "Hello"
          ],
          "expectedValue": "hiHellohi"
        },
        {
          "inData": [
            "aaa",
            "b"
          ],
          "expectedValue": "baaab"
        },
        {
          "inData": [
            "b",
            "aaa"
          ],
          "expectedValue": "baaab"
        },
        {
          "inData": [
            "aaa",
            ""
          ],
          "expectedValue": "aaa"
        },
        {
          "inData": [
            "",
            "bb"
          ],
          "expectedValue": "bb"
        },
        {
          "inData": [
            "aaa",
            "1234"
          ],
          "expectedValue": "aaa1234aaa"
        },
        {
          "inData": [
            "aaa",
            "bb"
          ],
          "expectedValue": "bbaaabb"
        },
        {
          "inData": [
            "a",
            "bb"
          ],
          "expectedValue": "abba"
        },
        {
          "inData": [
            "bb",
            "a"
          ],
          "expectedValue": "abba"
        },
        {
          "inData": [
            "xyz",
            "ab"
          ],
          "expectedValue": "abxyzab"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "nonStart",
    "description": "Given 2 strings, return their concatenation, except omit the first char of each. The strings will be at least length 1. ",
    "examples": "nonStart(\"Hello\", \"There\") → \"ellohere\" nonStart(\"java\", \"code\") → \"avaode\" nonStart(\"shotl\", \"java\") → \"hotlava\"\n",
    "template": "public String nonStart(String a, String b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "a"
        },
        {
          "type": "String",
          "name": "b"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello",
            "There"
          ],
          "expectedValue": "ellohere"
        },
        {
          "inData": [
            "java",
            "code"
          ],
          "expectedValue": "avaode"
        },
        {
          "inData": [
            "shotl",
            "java"
          ],
          "expectedValue": "hotlava"
        },
        {
          "inData": [
            "ab",
            "xy"
          ],
          "expectedValue": "by"
        },
        {
          "inData": [
            "ab",
            "x"
          ],
          "expectedValue": "b"
        },
        {
          "inData": [
            "x",
            "ac"
          ],
          "expectedValue": "c"
        },
        {
          "inData": [
            "a",
            "x"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "kit",
            "kat"
          ],
          "expectedValue": "itat"
        },
        {
          "inData": [
            "mart",
            "dart"
          ],
          "expectedValue": "artart"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "left2",
    "description": "Given a string, return a \"rotated left 2\" version where the first 2 chars are moved to the end. The string length will be at least 2. ",
    "examples": "left2(\"Hello\") → \"lloHe\" left2(\"java\") → \"vaja\" left2(\"Hi\") → \"Hi\"\n",
    "template": "public String left2(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "lloHe"
        },
        {
          "inData": [
            "java"
          ],
          "expectedValue": "vaja"
        },
        {
          "inData": [
            "Hi"
          ],
          "expectedValue": "Hi"
        },
        {
          "inData": [
            "code"
          ],
          "expectedValue": "deco"
        },
        {
          "inData": [
            "cat"
          ],
          "expectedValue": "tca"
        },
        {
          "inData": [
            "12345"
          ],
          "expectedValue": "34512"
        },
        {
          "inData": [
            "Chocolate"
          ],
          "expectedValue": "ocolateCh"
        },
        {
          "inData": [
            "bricks"
          ],
          "expectedValue": "icksbr"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "right2",
    "description": "Given a string, return a \"rotated right 2\" version where the last 2 chars are moved to the start. The string length will be at least 2. ",
    "examples": "right2(\"Hello\") → \"loHel\" right2(\"java\") → \"vaja\" right2(\"Hi\") → \"Hi\"\n",
    "template": "public String right2(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "loHel"
        },
        {
          "inData": [
            "java"
          ],
          "expectedValue": "vaja"
        },
        {
          "inData": [
            "Hi"
          ],
          "expectedValue": "Hi"
        },
        {
          "inData": [
            "code"
          ],
          "expectedValue": "deco"
        },
        {
          "inData": [
            "cat"
          ],
          "expectedValue": "atc"
        },
        {
          "inData": [
            "12345"
          ],
          "expectedValue": "45123"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "theEnd",
    "description": "Given a string, return a string length 1 from its front, unless \u003cb\u003efront\u003c/b\u003e is false, in which case return a string length 1 from its back. The string will be non-empty. ",
    "examples": "theEnd(\"Hello\", true) → \"H\" theEnd(\"Hello\", false) → \"o\" theEnd(\"oh\", true) → \"o\"\n",
    "template": "public String theEnd(String str, boolean front) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "boolean",
          "name": "front"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello",
            "true"
          ],
          "expectedValue": "H"
        },
        {
          "inData": [
            "Hello",
            "false"
          ],
          "expectedValue": "o"
        },
        {
          "inData": [
            "oh",
            "true"
          ],
          "expectedValue": "o"
        },
        {
          "inData": [
            "oh",
            "false"
          ],
          "expectedValue": "h"
        },
        {
          "inData": [
            "x",
            "true"
          ],
          "expectedValue": "x"
        },
        {
          "inData": [
            "x",
            "false"
          ],
          "expectedValue": "x"
        },
        {
          "inData": [
            "java",
            "true"
          ],
          "expectedValue": "j"
        },
        {
          "inData": [
            "chocolate",
            "false"
          ],
          "expectedValue": "e"
        },
        {
          "inData": [
            "1234",
            "true"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "code",
            "false"
          ],
          "expectedValue": "e"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "withouEnd2",
    "description": "Given a string, return a version without both the first and last char of the string. The string may be any length, including 0. ",
    "examples": "withouEnd2(\"Hello\") → \"ell\" withouEnd2(\"abc\") → \"b\" withouEnd2(\"ab\") → \"\"\n",
    "template": "public String withouEnd2(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "ell"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "b"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "coldy"
          ],
          "expectedValue": "old"
        },
        {
          "inData": [
            "java code"
          ],
          "expectedValue": "ava cod"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "middleTwo",
    "description": "Given a string of even length, return a string made of the middle two chars, so the string \"string\" yields \"ri\". The string length will be at least 2. ",
    "examples": "middleTwo(\"string\") → \"ri\" middleTwo(\"code\") → \"od\" middleTwo(\"Practice\") → \"ct\"\n",
    "template": "public String middleTwo(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "string"
          ],
          "expectedValue": "ri"
        },
        {
          "inData": [
            "code"
          ],
          "expectedValue": "od"
        },
        {
          "inData": [
            "Practice"
          ],
          "expectedValue": "ct"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "ab"
        },
        {
          "inData": [
            "0123456789"
          ],
          "expectedValue": "45"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "endsLy",
    "description": "Given a string, return true if it ends in \"ly\". ",
    "examples": "endsLy(\"oddly\") → true endsLy(\"y\") → false endsLy(\"oddy\") → false\n",
    "template": "public boolean endsLy(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "oddly"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "y"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "oddy"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "oddl"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "olydd"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "ly"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "falsey"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "evenly"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "nTwice",
    "description": "Given a string and an int n, return a string made of the first and last n chars from the string. The string length will be at least n. ",
    "examples": "nTwice(\"Hello\", 2) → \"Helo\" nTwice(\"Chocolate\", 3) → \"Choate\" nTwice(\"Chocolate\", 1) → \"Ce\"\n",
    "template": "public String nTwice(String str, int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello",
            "2"
          ],
          "expectedValue": "Helo"
        },
        {
          "inData": [
            "Chocolate",
            "3"
          ],
          "expectedValue": "Choate"
        },
        {
          "inData": [
            "Chocolate",
            "1"
          ],
          "expectedValue": "Ce"
        },
        {
          "inData": [
            "Chocolate",
            "0"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Hello",
            "4"
          ],
          "expectedValue": "Hellello"
        },
        {
          "inData": [
            "Code",
            "4"
          ],
          "expectedValue": "CodeCode"
        },
        {
          "inData": [
            "Code",
            "2"
          ],
          "expectedValue": "Code"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "twoChar",
    "description": "Given a string and an index, return a string length 2 starting at the given index. If the index is too big or too small to define a string length 2, use the first 2 chars. The string length will be at least 2. ",
    "examples": "twoChar(\"java\", 0) → \"ja\" twoChar(\"java\", 2) → \"va\" twoChar(\"java\", 3) → \"ja\"\n",
    "template": "public String twoChar(String str, int index) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "int",
          "name": "index"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "java",
            "0"
          ],
          "expectedValue": "ja"
        },
        {
          "inData": [
            "java",
            "2"
          ],
          "expectedValue": "va"
        },
        {
          "inData": [
            "java",
            "3"
          ],
          "expectedValue": "ja"
        },
        {
          "inData": [
            "java",
            "4"
          ],
          "expectedValue": "ja"
        },
        {
          "inData": [
            "java",
            "-1"
          ],
          "expectedValue": "ja"
        },
        {
          "inData": [
            "Hello",
            "0"
          ],
          "expectedValue": "He"
        },
        {
          "inData": [
            "Hello",
            "1"
          ],
          "expectedValue": "el"
        },
        {
          "inData": [
            "Hello",
            "99"
          ],
          "expectedValue": "He"
        },
        {
          "inData": [
            "Hello",
            "3"
          ],
          "expectedValue": "lo"
        },
        {
          "inData": [
            "Hello",
            "4"
          ],
          "expectedValue": "He"
        },
        {
          "inData": [
            "Hello",
            "5"
          ],
          "expectedValue": "He"
        },
        {
          "inData": [
            "Hello",
            "-7"
          ],
          "expectedValue": "He"
        },
        {
          "inData": [
            "Hello",
            "6"
          ],
          "expectedValue": "He"
        },
        {
          "inData": [
            "Hello",
            "-1"
          ],
          "expectedValue": "He"
        },
        {
          "inData": [
            "yay",
            "0"
          ],
          "expectedValue": "ya"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "middleThree",
    "description": "Given a string of odd length, return the string length 3 from its middle, so \"Candy\" yields \"and\". The string length will be at least 3. ",
    "examples": "middleThree(\"Candy\") → \"and\" middleThree(\"and\") → \"and\" middleThree(\"solving\") → \"lvi\"\n",
    "template": "public String middleThree(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Candy"
          ],
          "expectedValue": "and"
        },
        {
          "inData": [
            "and"
          ],
          "expectedValue": "and"
        },
        {
          "inData": [
            "solving"
          ],
          "expectedValue": "lvi"
        },
        {
          "inData": [
            "Hi yet Hi"
          ],
          "expectedValue": "yet"
        },
        {
          "inData": [
            "java yet java"
          ],
          "expectedValue": "yet"
        },
        {
          "inData": [
            "Chocolate"
          ],
          "expectedValue": "col"
        },
        {
          "inData": [
            "XabcxyzabcX"
          ],
          "expectedValue": "xyz"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "hasBad",
    "description": "Given a string, return true if \"bad\" appears starting at index 0 or 1 in the string, such as with \"badxxx\" or \"xbadxx\" but not \"xxbadxx\". The string may be any length, including 0. Note: use .equals() to compare 2 strings. ",
    "examples": "hasBad(\"badxx\") → true hasBad(\"xbadxx\") → true hasBad(\"xxbadxx\") → false\n",
    "template": "public boolean hasBad(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "badxx"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xbadxx"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xxbadxx"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "code"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "bad"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "ba"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xba"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xbad"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "badyy"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "atFirst",
    "description": "Given a string, return a string length 2 made of its first 2 chars. If the string length is less than 2, use \u0027@\u0027 for the missing chars. ",
    "examples": "atFirst(\"hello\") → \"he\" atFirst(\"hi\") → \"hi\" atFirst(\"h\") → \"h@\"\n",
    "template": "public String atFirst(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "hello"
          ],
          "expectedValue": "he"
        },
        {
          "inData": [
            "hi"
          ],
          "expectedValue": "hi"
        },
        {
          "inData": [
            "h"
          ],
          "expectedValue": "h@"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "@@"
        },
        {
          "inData": [
            "kitten"
          ],
          "expectedValue": "ki"
        },
        {
          "inData": [
            "java"
          ],
          "expectedValue": "ja"
        },
        {
          "inData": [
            "j"
          ],
          "expectedValue": "j@"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "lastChars",
    "description": "Given 2 strings, a and b, return a new string made of the first char of a and the last char of b, so \"yo\" and \"java\" yields \"ya\". If either string is length 0, use \u0027@\u0027 for its missing char. ",
    "examples": "lastChars(\"last\", \"chars\") → \"ls\" lastChars(\"yo\", \"java\") → \"ya\" lastChars(\"hi\", \"\") → \"h@\"\n",
    "template": "public String lastChars(String a, String b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "a"
        },
        {
          "type": "String",
          "name": "b"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "last",
            "chars"
          ],
          "expectedValue": "ls"
        },
        {
          "inData": [
            "yo",
            "java"
          ],
          "expectedValue": "ya"
        },
        {
          "inData": [
            "hi",
            ""
          ],
          "expectedValue": "h@"
        },
        {
          "inData": [
            "",
            "hello"
          ],
          "expectedValue": "@o"
        },
        {
          "inData": [
            "",
            ""
          ],
          "expectedValue": "@@"
        },
        {
          "inData": [
            "kitten",
            "hi"
          ],
          "expectedValue": "ki"
        },
        {
          "inData": [
            "k",
            "zip"
          ],
          "expectedValue": "kp"
        },
        {
          "inData": [
            "kitten",
            ""
          ],
          "expectedValue": "k@"
        },
        {
          "inData": [
            "kitten",
            "zip"
          ],
          "expectedValue": "kp"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "conCat",
    "description": "Given two strings, append them together (known as \"concatenation\") and return the result. However, if the concatenation creates a double-char, then omit one of the chars, so \"abc\" and \"cat\" yields \"abcat\". ",
    "examples": "conCat(\"abc\", \"cat\") → \"abcat\" conCat(\"dog\", \"cat\") → \"dogcat\" conCat(\"abc\", \"\") → \"abc\"\n",
    "template": "public String conCat(String a, String b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "a"
        },
        {
          "type": "String",
          "name": "b"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abc",
            "cat"
          ],
          "expectedValue": "abcat"
        },
        {
          "inData": [
            "dog",
            "cat"
          ],
          "expectedValue": "dogcat"
        },
        {
          "inData": [
            "abc",
            ""
          ],
          "expectedValue": "abc"
        },
        {
          "inData": [
            "",
            "cat"
          ],
          "expectedValue": "cat"
        },
        {
          "inData": [
            "pig",
            "g"
          ],
          "expectedValue": "pig"
        },
        {
          "inData": [
            "pig",
            "doggy"
          ],
          "expectedValue": "pigdoggy"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "lastTwo",
    "description": "Given a string of any length, return a new string where the last 2 chars, if present, are swapped, so \"coding\" yields \"codign\". ",
    "examples": "lastTwo(\"coding\") → \"codign\" lastTwo(\"cat\") → \"cta\" lastTwo(\"ab\") → \"ba\"\n",
    "template": "public String lastTwo(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "coding"
          ],
          "expectedValue": "codign"
        },
        {
          "inData": [
            "cat"
          ],
          "expectedValue": "cta"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "ba"
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": "a"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "seeColor",
    "description": "Given a string, if the string begins with \"red\" or \"blue\" return that color string, otherwise return the empty string. ",
    "examples": "seeColor(\"redxx\") → \"red\" seeColor(\"xxred\") → \"\" seeColor(\"blueTimes\") → \"blue\"\n",
    "template": "public String seeColor(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "redxx"
          ],
          "expectedValue": "red"
        },
        {
          "inData": [
            "xxred"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "blueTimes"
          ],
          "expectedValue": "blue"
        },
        {
          "inData": [
            "NoColor"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "red"
          ],
          "expectedValue": "red"
        },
        {
          "inData": [
            "re"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "blu"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "blue"
          ],
          "expectedValue": "blue"
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "xyzred"
          ],
          "expectedValue": ""
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "frontAgain",
    "description": "Given a string, return true if the first 2 chars in the string also appear at the end of the string, such as with \"edited\". ",
    "examples": "frontAgain(\"edited\") → true frontAgain(\"edit\") → false frontAgain(\"ed\") → true\n",
    "template": "public boolean frontAgain(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "edited"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "edit"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "ed"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "jj"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "jjj"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "jjjj"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "jjjk"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "java"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "javaja"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "minCat",
    "description": "Given two strings, append them together (known as \"concatenation\") and return the result. However, if the strings are different lengths, omit chars from the longer string so it is the same length as the shorter string. So \"Hello\" and \"Hi\" yield \"loHi\". The strings may be any length. ",
    "examples": "minCat(\"Hello\", \"Hi\") → \"loHi\" minCat(\"Hello\", \"java\") → \"ellojava\" minCat(\"java\", \"Hello\") → \"javaello\"\n",
    "template": "public String minCat(String a, String b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "a"
        },
        {
          "type": "String",
          "name": "b"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello",
            "Hi"
          ],
          "expectedValue": "loHi"
        },
        {
          "inData": [
            "Hello",
            "java"
          ],
          "expectedValue": "ellojava"
        },
        {
          "inData": [
            "java",
            "Hello"
          ],
          "expectedValue": "javaello"
        },
        {
          "inData": [
            "abc",
            "x"
          ],
          "expectedValue": "cx"
        },
        {
          "inData": [
            "x",
            "abc"
          ],
          "expectedValue": "xc"
        },
        {
          "inData": [
            "abc",
            ""
          ],
          "expectedValue": ""
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "extraFront",
    "description": "Given a string, return a new string made of 3 copies of the first 2 chars of the original string. The string may be any length. If there are fewer than 2 chars, use whatever is there. ",
    "examples": "extraFront(\"Hello\") → \"HeHeHe\" extraFront(\"ab\") → \"ababab\" extraFront(\"H\") → \"HHH\"\n",
    "template": "public String extraFront(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "HeHeHe"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "ababab"
        },
        {
          "inData": [
            "H"
          ],
          "expectedValue": "HHH"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Candy"
          ],
          "expectedValue": "CaCaCa"
        },
        {
          "inData": [
            "Code"
          ],
          "expectedValue": "CoCoCo"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "without2",
    "description": "Given a string, if a length 2 substring appears at both its beginning and end, return a string without the substring at the beginning, so \"HelloHe\" yields \"lloHe\". The substring may overlap with itself, so \"Hi\" yields \"\". Otherwise, return the original string unchanged. ",
    "examples": "without2(\"HelloHe\") → \"lloHe\" without2(\"HelloHi\") → \"HelloHi\" without2(\"Hi\") → \"\"\n",
    "template": "public String without2(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "HelloHe"
          ],
          "expectedValue": "lloHe"
        },
        {
          "inData": [
            "HelloHi"
          ],
          "expectedValue": "HelloHi"
        },
        {
          "inData": [
            "Hi"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Chocolate"
          ],
          "expectedValue": "Chocolate"
        },
        {
          "inData": [
            "xxx"
          ],
          "expectedValue": "x"
        },
        {
          "inData": [
            "xx"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "x"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Fruits"
          ],
          "expectedValue": "Fruits"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "deFront",
    "description": "Given a string, return a version without the first 2 chars. Except keep the first char if it is \u0027a\u0027 and keep the second char if it is \u0027b\u0027. The string may be any length. Harder than it looks. ",
    "examples": "deFront(\"Hello\") → \"llo\" deFront(\"java\") → \"va\" deFront(\"away\") → \"aay\"\n",
    "template": "public String deFront(String str) {    \n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "llo"
        },
        {
          "inData": [
            "java"
          ],
          "expectedValue": "va"
        },
        {
          "inData": [
            "away"
          ],
          "expectedValue": "aay"
        },
        {
          "inData": [
            "axy"
          ],
          "expectedValue": "ay"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "abc"
        },
        {
          "inData": [
            "xby"
          ],
          "expectedValue": "by"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "ab"
        },
        {
          "inData": [
            "ax"
          ],
          "expectedValue": "a"
        },
        {
          "inData": [
            "axb"
          ],
          "expectedValue": "ab"
        },
        {
          "inData": [
            "aaa"
          ],
          "expectedValue": "aa"
        },
        {
          "inData": [
            "xbc"
          ],
          "expectedValue": "bc"
        },
        {
          "inData": [
            "bbb"
          ],
          "expectedValue": "bb"
        },
        {
          "inData": [
            "bazz"
          ],
          "expectedValue": "zz"
        },
        {
          "inData": [
            "ba"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "abxyz"
          ],
          "expectedValue": "abxyz"
        },
        {
          "inData": [
            "hi"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "his"
          ],
          "expectedValue": "s"
        },
        {
          "inData": [
            "xz"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "zzz"
          ],
          "expectedValue": "z"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "startWord",
    "description": "Given a string and a second \"word\" string, we\u0027ll say that the word matches the string if it appears at the front of the string, except its first char does not need to match exactly. On a match, return the front of the string, or otherwise return the empty string. So, so with the string \"hippo\" the word \"hi\" returns \"hi\" and \"xip\" returns \"hip\". The word will be at least length 1. ",
    "examples": "startWord(\"hippo\", \"hi\") → \"hi\" startWord(\"hippo\", \"xip\") → \"hip\" startWord(\"hippo\", \"i\") → \"h\"\n",
    "template": "public String startWord(String str, String word) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "String",
          "name": "word"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "hippo",
            "hi"
          ],
          "expectedValue": "hi"
        },
        {
          "inData": [
            "hippo",
            "xip"
          ],
          "expectedValue": "hip"
        },
        {
          "inData": [
            "hippo",
            "i"
          ],
          "expectedValue": "h"
        },
        {
          "inData": [
            "hippo",
            "ix"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "h",
            "ix"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "",
            "i"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "hip",
            "zi"
          ],
          "expectedValue": "hi"
        },
        {
          "inData": [
            "hip",
            "zip"
          ],
          "expectedValue": "hip"
        },
        {
          "inData": [
            "hip",
            "zig"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "h",
            "z"
          ],
          "expectedValue": "h"
        },
        {
          "inData": [
            "hippo",
            "xippo"
          ],
          "expectedValue": "hippo"
        },
        {
          "inData": [
            "hippo",
            "xyz"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "hippo",
            "hip"
          ],
          "expectedValue": "hip"
        },
        {
          "inData": [
            "kitten",
            "cit"
          ],
          "expectedValue": "kit"
        },
        {
          "inData": [
            "kit",
            "cit"
          ],
          "expectedValue": "kit"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "withoutX",
    "description": "Given a string, if the first or last chars are \u0027x\u0027, return the string without those \u0027x\u0027 chars, and otherwise return the string unchanged. ",
    "examples": "withoutX(\"xHix\") → \"Hi\" withoutX(\"xHi\") → \"Hi\" withoutX(\"Hxix\") → \"Hxi\"\n",
    "template": "public String withoutX(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "xHix"
          ],
          "expectedValue": "Hi"
        },
        {
          "inData": [
            "xHi"
          ],
          "expectedValue": "Hi"
        },
        {
          "inData": [
            "Hxix"
          ],
          "expectedValue": "Hxi"
        },
        {
          "inData": [
            "Hi"
          ],
          "expectedValue": "Hi"
        },
        {
          "inData": [
            "xxHi"
          ],
          "expectedValue": "xHi"
        },
        {
          "inData": [
            "Hix"
          ],
          "expectedValue": "Hi"
        },
        {
          "inData": [
            "xaxbx"
          ],
          "expectedValue": "axb"
        },
        {
          "inData": [
            "xx"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "Hello"
        },
        {
          "inData": [
            "Hexllo"
          ],
          "expectedValue": "Hexllo"
        }
      ]
    }
  },
  {
    "groupName": "String-1",
    "title": "withoutX2",
    "description": "Given a string, if one or both of the first 2 chars is \u0027x\u0027, return the string without those \u0027x\u0027 chars, and otherwise return the string unchanged. This is a little harder than it looks. ",
    "examples": "withoutX2(\"xHi\") → \"Hi\" withoutX2(\"Hxi\") → \"Hi\" withoutX2(\"Hi\") → \"Hi\"\n",
    "template": "public String withoutX2(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "xHi"
          ],
          "expectedValue": "Hi"
        },
        {
          "inData": [
            "Hxi"
          ],
          "expectedValue": "Hi"
        },
        {
          "inData": [
            "Hi"
          ],
          "expectedValue": "Hi"
        },
        {
          "inData": [
            "xxHi"
          ],
          "expectedValue": "Hi"
        },
        {
          "inData": [
            "Hix"
          ],
          "expectedValue": "Hix"
        },
        {
          "inData": [
            "xaxb"
          ],
          "expectedValue": "axb"
        },
        {
          "inData": [
            "xx"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "Hello"
        },
        {
          "inData": [
            "Hexllo"
          ],
          "expectedValue": "Hexllo"
        },
        {
          "inData": [
            "xHxllo"
          ],
          "expectedValue": "Hxllo"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "firstLast6",
    "description": "Given an array of ints, return true if 6 appears as either the first or last element in the array. The array will be length 1 or more. ",
    "examples": "firstLast6({1, 2, 6}) → true firstLast6({6, 1, 2, 3}) → true firstLast6({13, 6, 1, 2, 3}) → false\n",
    "template": "public boolean firstLast6(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 6}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{6, 1, 2, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{13, 6, 1, 2, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{13, 6, 1, 2, 6}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 2, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 6, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 6}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{6}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{5, 6}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{5, 5}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 6}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3, 4}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "sameFirstLast",
    "description": "Given an array of ints, return true if the array is length 1 or more, and the first element and the last element are equal. ",
    "examples": "sameFirstLast({1, 2, 3}) → false sameFirstLast({1, 2, 3, 1}) → true sameFirstLast({1, 2, 1}) → true\n",
    "template": "public boolean sameFirstLast(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{7}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 13}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{13, 2, 3, 4, 5, 13}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{7, 7}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "makePi",
    "description": "Return an int array length 3 containing the first 3 digits of pi, {3, 1, 4}. ",
    "examples": "makePi() → {3, 1, 4}\n",
    "template": "public int[] makePi() {\n  \n}",
    "methodSignature": {
      "inArgList": [],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [],
          "expectedValue": "{3, 1, 4}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "commonEnd",
    "description": "Given 2 arrays of ints, a and b, return true if they have the same first element or they have the same last element. Both arrays will be length 1 or more. ",
    "examples": "commonEnd({1, 2, 3}, {7, 3}) → true commonEnd({1, 2, 3}, {7, 3, 2}) → false commonEnd({1, 2, 3}, {1, 3}) → true\n",
    "template": "public boolean commonEnd(int[] a, int[] b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "a"
        },
        {
          "type": "int[]",
          "name": "b"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}",
            "{7, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3}",
            "{7, 3, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3}",
            "{1, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3}",
            "{1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3}",
            "{2}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "sum3",
    "description": "Given an array of ints length 3, return the sum of all the elements. ",
    "examples": "sum3({1, 2, 3}) → 6 sum3({5, 11, 2}) → 18 sum3({7, 0, 0}) → 7\n",
    "template": "public int sum3(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "{5, 11, 2}"
          ],
          "expectedValue": "18"
        },
        {
          "inData": [
            "{7, 0, 0}"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "{1, 2, 1}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{1, 1, 1}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{2, 7, 2}"
          ],
          "expectedValue": "11"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "rotateLeft3",
    "description": "Given an array of ints length 3, return an array with the elements \"rotated left\" so {1, 2, 3} yields {2, 3, 1}. ",
    "examples": "rotateLeft3({1, 2, 3}) → {2, 3, 1} rotateLeft3({5, 11, 9}) → {11, 9, 5} rotateLeft3({7, 0, 0}) → {0, 0, 7}\n",
    "template": "public int[] rotateLeft3(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "{2, 3, 1}"
        },
        {
          "inData": [
            "{5, 11, 9}"
          ],
          "expectedValue": "{11, 9, 5}"
        },
        {
          "inData": [
            "{7, 0, 0}"
          ],
          "expectedValue": "{0, 0, 7}"
        },
        {
          "inData": [
            "{1, 2, 1}"
          ],
          "expectedValue": "{2, 1, 1}"
        },
        {
          "inData": [
            "{0, 0, 1}"
          ],
          "expectedValue": "{0, 1, 0}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "reverse3",
    "description": "Given an array of ints length 3, return a new array with the elements in reverse order, so {1, 2, 3} becomes {3, 2, 1}. ",
    "examples": "reverse3({1, 2, 3}) → {3, 2, 1} reverse3({5, 11, 9}) → {9, 11, 5} reverse3({7, 0, 0}) → {0, 0, 7}\n",
    "template": "public int[] reverse3(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "{3, 2, 1}"
        },
        {
          "inData": [
            "{5, 11, 9}"
          ],
          "expectedValue": "{9, 11, 5}"
        },
        {
          "inData": [
            "{7, 0, 0}"
          ],
          "expectedValue": "{0, 0, 7}"
        },
        {
          "inData": [
            "{2, 1, 2}"
          ],
          "expectedValue": "{2, 1, 2}"
        },
        {
          "inData": [
            "{1, 2, 1}"
          ],
          "expectedValue": "{1, 2, 1}"
        },
        {
          "inData": [
            "{2, 11, 3}"
          ],
          "expectedValue": "{3, 11, 2}"
        },
        {
          "inData": [
            "{0, 6, 5}"
          ],
          "expectedValue": "{5, 6, 0}"
        },
        {
          "inData": [
            "{7, 2, 3}"
          ],
          "expectedValue": "{3, 2, 7}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "maxEnd3",
    "description": "Given an array of ints length 3, figure out which is larger between the first and last elements in the array, and set all the other elements to be that value. Return the changed array. ",
    "examples": "maxEnd3({1, 2, 3}) → {3, 3, 3} maxEnd3({11, 5, 9}) → {11, 11, 11} maxEnd3({2, 11, 3}) → {3, 3, 3}\n",
    "template": "public int[] maxEnd3(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "{3, 3, 3}"
        },
        {
          "inData": [
            "{11, 5, 9}"
          ],
          "expectedValue": "{11, 11, 11}"
        },
        {
          "inData": [
            "{2, 11, 3}"
          ],
          "expectedValue": "{3, 3, 3}"
        },
        {
          "inData": [
            "{11, 3, 3}"
          ],
          "expectedValue": "{11, 11, 11}"
        },
        {
          "inData": [
            "{3, 11, 11}"
          ],
          "expectedValue": "{11, 11, 11}"
        },
        {
          "inData": [
            "{2, 2, 2}"
          ],
          "expectedValue": "{2, 2, 2}"
        },
        {
          "inData": [
            "{2, 11, 2}"
          ],
          "expectedValue": "{2, 2, 2}"
        },
        {
          "inData": [
            "{0, 0, 1}"
          ],
          "expectedValue": "{1, 1, 1}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "sum2",
    "description": "Given an array of ints, return the sum of the first 2 elements in the array. If the array length is less than 2, just sum up the elements that exist, returning 0 if the array is length 0. ",
    "examples": "sum2({1, 2, 3}) → 3 sum2({1, 1}) → 2 sum2({1, 1, 1, 1}) → 2\n",
    "template": "public int sum2(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{1, 1}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 1, 1, 1}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{4, 5, 6}"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "{4}"
          ],
          "expectedValue": "4"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "middleWay",
    "description": "Given 2 int arrays, a and b, each length 3, return a new array length 2 containing their middle elements. ",
    "examples": "middleWay({1, 2, 3}, {4, 5, 6}) → {2, 5} middleWay({7, 7, 7}, {3, 8, 0}) → {7, 8} middleWay({5, 2, 9}, {1, 4, 5}) → {2, 4}\n",
    "template": "public int[] middleWay(int[] a, int[] b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "a"
        },
        {
          "type": "int[]",
          "name": "b"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}",
            "{4, 5, 6}"
          ],
          "expectedValue": "{2, 5}"
        },
        {
          "inData": [
            "{7, 7, 7}",
            "{3, 8, 0}"
          ],
          "expectedValue": "{7, 8}"
        },
        {
          "inData": [
            "{5, 2, 9}",
            "{1, 4, 5}"
          ],
          "expectedValue": "{2, 4}"
        },
        {
          "inData": [
            "{1, 9, 7}",
            "{4, 8, 8}"
          ],
          "expectedValue": "{9, 8}"
        },
        {
          "inData": [
            "{1, 2, 3}",
            "{3, 1, 4}"
          ],
          "expectedValue": "{2, 1}"
        },
        {
          "inData": [
            "{1, 2, 3}",
            "{4, 1, 1}"
          ],
          "expectedValue": "{2, 1}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "makeEnds",
    "description": "Given an array of ints, return a new array length 2 containing the first and last elements from the original array. The original array will be length 1 or more. ",
    "examples": "makeEnds({1, 2, 3}) → {1, 3} makeEnds({1, 2, 3, 4}) → {1, 4} makeEnds({7, 4, 6, 2}) → {7, 2}\n",
    "template": "public int[] makeEnds(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "{1, 3}"
        },
        {
          "inData": [
            "{1, 2, 3, 4}"
          ],
          "expectedValue": "{1, 4}"
        },
        {
          "inData": [
            "{7, 4, 6, 2}"
          ],
          "expectedValue": "{7, 2}"
        },
        {
          "inData": [
            "{1, 2, 2, 2, 2, 2, 2, 3}"
          ],
          "expectedValue": "{1, 3}"
        },
        {
          "inData": [
            "{7, 4}"
          ],
          "expectedValue": "{7, 4}"
        },
        {
          "inData": [
            "{7}"
          ],
          "expectedValue": "{7, 7}"
        },
        {
          "inData": [
            "{5, 2, 9}"
          ],
          "expectedValue": "{5, 9}"
        },
        {
          "inData": [
            "{2, 3, 4, 1}"
          ],
          "expectedValue": "{2, 1}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "has23",
    "description": "Given an int array length 2, return true if it contains a 2 or a 3. ",
    "examples": "has23({2, 5}) → true has23({4, 3}) → true has23({4, 5}) → false\n",
    "template": "public boolean has23(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{2, 5}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{4, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{4, 5}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{7, 7}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 9}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{9, 5}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "no23",
    "description": "Given an int array length 2, return true if it does not contain a 2 or 3. ",
    "examples": "no23({4, 5}) → true no23({4, 2}) → false no23({3, 5}) → false\n",
    "template": "public boolean no23(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{4, 5}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{4, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 5}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 9}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 9}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{7, 8}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{8, 7}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "makeLast",
    "description": "Given an int array, return a new array with double the length where its last element is the same as the original array, and all the other elements are 0. The original array will be length 1 or more. Note: by default, a new int array contains all 0\u0027s. ",
    "examples": "makeLast({4, 5, 6}) → {0, 0, 0, 0, 0, 6} makeLast({1, 2}) → {0, 0, 0, 2} makeLast({3}) → {0, 3}\n",
    "template": "public int[] makeLast(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{4, 5, 6}"
          ],
          "expectedValue": "{0, 0, 0, 0, 0, 6}"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "{0, 0, 0, 2}"
        },
        {
          "inData": [
            "{3}"
          ],
          "expectedValue": "{0, 3}"
        },
        {
          "inData": [
            "{0}"
          ],
          "expectedValue": "{0, 0}"
        },
        {
          "inData": [
            "{7, 7, 7}"
          ],
          "expectedValue": "{0, 0, 0, 0, 0, 7}"
        },
        {
          "inData": [
            "{3, 1, 4}"
          ],
          "expectedValue": "{0, 0, 0, 0, 0, 4}"
        },
        {
          "inData": [
            "{1, 2, 3, 4}"
          ],
          "expectedValue": "{0, 0, 0, 0, 0, 0, 0, 4}"
        },
        {
          "inData": [
            "{1, 2, 3, 0}"
          ],
          "expectedValue": "{0, 0, 0, 0, 0, 0, 0, 0}"
        },
        {
          "inData": [
            "{2, 4}"
          ],
          "expectedValue": "{0, 0, 0, 4}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "double23",
    "description": "Given an int array, return true if the array contains 2 twice, or 3 twice. The array will be length 0, 1, or 2. ",
    "examples": "double23({2, 2}) → true double23({3, 3}) → true double23({2, 3}) → false\n",
    "template": "public boolean double23(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{4, 5}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 4}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "fix23",
    "description": "Given an int array length 3, if there is a 2 in the array immediately followed by a 3, set the 3 element to 0. Return the changed array. ",
    "examples": "fix23({1, 2, 3}) → {1, 2, 0} fix23({2, 3, 5}) → {2, 0, 5} fix23({1, 2, 1}) → {1, 2, 1}\n",
    "template": "public int[] fix23(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "{1, 2, 0}"
        },
        {
          "inData": [
            "{2, 3, 5}"
          ],
          "expectedValue": "{2, 0, 5}"
        },
        {
          "inData": [
            "{1, 2, 1}"
          ],
          "expectedValue": "{1, 2, 1}"
        },
        {
          "inData": [
            "{3, 2, 1}"
          ],
          "expectedValue": "{3, 2, 1}"
        },
        {
          "inData": [
            "{2, 2, 3}"
          ],
          "expectedValue": "{2, 2, 0}"
        },
        {
          "inData": [
            "{2, 3, 3}"
          ],
          "expectedValue": "{2, 0, 3}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "start1",
    "description": "Start with 2 int arrays, a and b, of any length. Return how many of the arrays have 1 as their first element. ",
    "examples": "start1({1, 2, 3}, {1, 3}) → 2 start1({7, 2, 3}, {1}) → 1 start1({1, 2}, {}) → 1\n",
    "template": "public int start1(int[] a, int[] b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "a"
        },
        {
          "type": "int[]",
          "name": "b"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}",
            "{1, 3}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{7, 2, 3}",
            "{1}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{1, 2}",
            "{}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{}",
            "{1, 2}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{7}",
            "{}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{7}",
            "{1}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{1}",
            "{1}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{7}",
            "{8}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{}",
            "{}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{1, 3}",
            "{1}"
          ],
          "expectedValue": "2"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "biggerTwo",
    "description": "Start with 2 int arrays, a and b, each length 2. Consider the sum of the values in each array. Return the array which has the largest sum. In event of a tie, return a. ",
    "examples": "biggerTwo({1, 2}, {3, 4}) → {3, 4} biggerTwo({3, 4}, {1, 2}) → {3, 4} biggerTwo({1, 1}, {1, 2}) → {1, 2}\n",
    "template": "public int[] biggerTwo(int[] a, int[] b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "a"
        },
        {
          "type": "int[]",
          "name": "b"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2}",
            "{3, 4}"
          ],
          "expectedValue": "{3, 4}"
        },
        {
          "inData": [
            "{3, 4}",
            "{1, 2}"
          ],
          "expectedValue": "{3, 4}"
        },
        {
          "inData": [
            "{1, 1}",
            "{1, 2}"
          ],
          "expectedValue": "{1, 2}"
        },
        {
          "inData": [
            "{2, 1}",
            "{1, 1}"
          ],
          "expectedValue": "{2, 1}"
        },
        {
          "inData": [
            "{2, 2}",
            "{1, 3}"
          ],
          "expectedValue": "{2, 2}"
        },
        {
          "inData": [
            "{1, 3}",
            "{2, 2}"
          ],
          "expectedValue": "{1, 3}"
        },
        {
          "inData": [
            "{6, 7}",
            "{3, 1}"
          ],
          "expectedValue": "{6, 7}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "makeMiddle",
    "description": "Given an array of ints of even length, return a new array length 2 containing the middle two elements from the original array. The original array will be length 2 or more. ",
    "examples": "makeMiddle({1, 2, 3, 4}) → {2, 3} makeMiddle({7, 1, 2, 3, 4, 9}) → {2, 3} makeMiddle({1, 2}) → {1, 2}\n",
    "template": "public int[] makeMiddle(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3, 4}"
          ],
          "expectedValue": "{2, 3}"
        },
        {
          "inData": [
            "{7, 1, 2, 3, 4, 9}"
          ],
          "expectedValue": "{2, 3}"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "{1, 2}"
        },
        {
          "inData": [
            "{5, 2, 4, 7}"
          ],
          "expectedValue": "{2, 4}"
        },
        {
          "inData": [
            "{9, 0, 4, 3, 9, 1}"
          ],
          "expectedValue": "{4, 3}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "plusTwo",
    "description": "Given 2 int arrays, each length 2, return a new array length 4 containing all their elements. ",
    "examples": "plusTwo({1, 2}, {3, 4}) → {1, 2, 3, 4} plusTwo({4, 4}, {2, 2}) → {4, 4, 2, 2} plusTwo({9, 2}, {3, 4}) → {9, 2, 3, 4}\n",
    "template": "public int[] plusTwo(int[] a, int[] b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "a"
        },
        {
          "type": "int[]",
          "name": "b"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2}",
            "{3, 4}"
          ],
          "expectedValue": "{1, 2, 3, 4}"
        },
        {
          "inData": [
            "{4, 4}",
            "{2, 2}"
          ],
          "expectedValue": "{4, 4, 2, 2}"
        },
        {
          "inData": [
            "{9, 2}",
            "{3, 4}"
          ],
          "expectedValue": "{9, 2, 3, 4}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "swapEnds",
    "description": "Given an array of ints, swap the first and last elements in the array. Return the modified array. The array length will be at least 1. ",
    "examples": "swapEnds({1, 2, 3, 4}) → {4, 2, 3, 1} swapEnds({1, 2, 3}) → {3, 2, 1} swapEnds({8, 6, 7, 9, 5}) → {5, 6, 7, 9, 8}\n",
    "template": "public int[] swapEnds(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3, 4}"
          ],
          "expectedValue": "{4, 2, 3, 1}"
        },
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "{3, 2, 1}"
        },
        {
          "inData": [
            "{8, 6, 7, 9, 5}"
          ],
          "expectedValue": "{5, 6, 7, 9, 8}"
        },
        {
          "inData": [
            "{3, 1, 4, 1, 5, 9}"
          ],
          "expectedValue": "{9, 1, 4, 1, 5, 3}"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "{2, 1}"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "{1}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "midThree",
    "description": "Given an array of ints of odd length, return a new array length 3 containing the elements from the middle of the array. The array length will be at least 3. ",
    "examples": "midThree({1, 2, 3, 4, 5}) → {2, 3, 4} midThree({8, 6, 7, 5, 3, 0, 9}) → {7, 5, 3} midThree({1, 2, 3}) → {1, 2, 3}\n",
    "template": "public int[] midThree(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3, 4, 5}"
          ],
          "expectedValue": "{2, 3, 4}"
        },
        {
          "inData": [
            "{8, 6, 7, 5, 3, 0, 9}"
          ],
          "expectedValue": "{7, 5, 3}"
        },
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "{1, 2, 3}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "maxTriple",
    "description": "Given an array of ints of odd length, look at the first, last, and middle values in the array and return the largest. The array length will be a least 1. ",
    "examples": "maxTriple({1, 2, 3}) → 3 maxTriple({1, 5, 3}) → 5 maxTriple({5, 2, 3}) → 5\n",
    "template": "public int maxTriple(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{1, 5, 3}"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "{5, 2, 3}"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "{1, 2, 3, 1, 1}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{1, 7, 3, 1, 5}"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "{5, 1, 3, 7, 1}"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "{5, 1, 7, 3, 7, 8, 1}"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "{5, 1, 7, 9, 7, 8, 1}"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "{5, 1, 7, 3, 7, 8, 9}"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "{2, 2, 5, 1, 1}"
          ],
          "expectedValue": "5"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "frontPiece",
    "description": "Given an int array of any length, return a new array of its first 2 elements. If the array is smaller than length 2, use whatever elements are present. ",
    "examples": "frontPiece({1, 2, 3}) → {1, 2} frontPiece({1, 2}) → {1, 2} frontPiece({1}) → {1}\n",
    "template": "public int[] frontPiece(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "{1, 2}"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "{1, 2}"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "{1}"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "{6, 5, 0}"
          ],
          "expectedValue": "{6, 5}"
        },
        {
          "inData": [
            "{6, 5}"
          ],
          "expectedValue": "{6, 5}"
        },
        {
          "inData": [
            "{3, 1, 4, 1, 5}"
          ],
          "expectedValue": "{3, 1}"
        },
        {
          "inData": [
            "{6}"
          ],
          "expectedValue": "{6}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "unlucky1",
    "description": "We\u0027ll say that a 1 immediately followed by a 3 in an array is an \"unlucky\" 1. Return true if the given array contains an unlucky 1 in the first 2 or last 2 positions in the array. ",
    "examples": "unlucky1({1, 3, 4, 5}) → true unlucky1({2, 1, 3, 4, 5}) → true unlucky1({1, 1, 1}) → false\n",
    "template": "public boolean unlucky1(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 3, 4, 5}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 1, 3, 4, 5}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 3, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 3, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1, 1, 3, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1, 3, 1, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 1, 1, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 4, 1, 5}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1, 2, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 3, 2, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 3, 1, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 1, 3}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "make2",
    "description": "Given 2 int arrays, a and b, return a new array length 2 containing, as much as will fit, the elements from a followed by the elements from b. The arrays may be any length, including 0, but there will be 2 or more elements available between the 2 arrays. ",
    "examples": "make2({4, 5}, {1, 2, 3}) → {4, 5} make2({4}, {1, 2, 3}) → {4, 1} make2({}, {1, 2}) → {1, 2}\n",
    "template": "public int[] make2(int[] a, int[] b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "a"
        },
        {
          "type": "int[]",
          "name": "b"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{4, 5}",
            "{1, 2, 3}"
          ],
          "expectedValue": "{4, 5}"
        },
        {
          "inData": [
            "{4}",
            "{1, 2, 3}"
          ],
          "expectedValue": "{4, 1}"
        },
        {
          "inData": [
            "{}",
            "{1, 2}"
          ],
          "expectedValue": "{1, 2}"
        },
        {
          "inData": [
            "{1, 2}",
            "{}"
          ],
          "expectedValue": "{1, 2}"
        },
        {
          "inData": [
            "{3}",
            "{1, 2, 3}"
          ],
          "expectedValue": "{3, 1}"
        },
        {
          "inData": [
            "{3}",
            "{1}"
          ],
          "expectedValue": "{3, 1}"
        },
        {
          "inData": [
            "{3, 1, 4}",
            "{}"
          ],
          "expectedValue": "{3, 1}"
        },
        {
          "inData": [
            "{1}",
            "{1}"
          ],
          "expectedValue": "{1, 1}"
        },
        {
          "inData": [
            "{1, 2, 3}",
            "{7, 8}"
          ],
          "expectedValue": "{1, 2}"
        },
        {
          "inData": [
            "{7, 8}",
            "{1, 2, 3}"
          ],
          "expectedValue": "{7, 8}"
        },
        {
          "inData": [
            "{7}",
            "{1, 2, 3}"
          ],
          "expectedValue": "{7, 1}"
        },
        {
          "inData": [
            "{5, 4}",
            "{2, 3, 7}"
          ],
          "expectedValue": "{5, 4}"
        }
      ]
    }
  },
  {
    "groupName": "Array-1",
    "title": "front11",
    "description": "Given 2 int arrays, a and b, of any length, return a new array with the first element of each array. If either array is length 0, ignore that array. ",
    "examples": "front11({1, 2, 3}, {7, 9, 8}) → {1, 7} front11({1}, {2}) → {1, 2} front11({1, 7}, {}) → {1}\n",
    "template": "public int[] front11(int[] a, int[] b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "a"
        },
        {
          "type": "int[]",
          "name": "b"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}",
            "{7, 9, 8}"
          ],
          "expectedValue": "{1, 7}"
        },
        {
          "inData": [
            "{1}",
            "{2}"
          ],
          "expectedValue": "{1, 2}"
        },
        {
          "inData": [
            "{1, 7}",
            "{}"
          ],
          "expectedValue": "{1}"
        },
        {
          "inData": [
            "{}",
            "{2, 8}"
          ],
          "expectedValue": "{2}"
        },
        {
          "inData": [
            "{}",
            "{}"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "{3}",
            "{1, 4, 1, 9}"
          ],
          "expectedValue": "{3, 1}"
        },
        {
          "inData": [
            "{1, 4, 1, 9}",
            "{}"
          ],
          "expectedValue": "{1}"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "cigarParty",
    "description": "When squirrels get together for a party, they like to have cigars. A squirrel party is successful when the number of cigars is between 40 and 60, inclusive. Unless it is the weekend, in which case there is no upper bound on the number of cigars. Return true if the party with the given values is successful, or false otherwise. ",
    "examples": "cigarParty(30, false) → false cigarParty(50, false) → true cigarParty(70, true) → true\n",
    "template": "public boolean cigarParty(int cigars, boolean isWeekend) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "cigars"
        },
        {
          "type": "boolean",
          "name": "isWeekend"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "30",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "50",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "70",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "30",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "50",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "60",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "61",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "40",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "39",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "40",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "39",
            "true"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "dateFashion",
    "description": "You and your date are trying to get a table at a restaurant. The parameter \"you\" is the stylishness of your clothes, in the range 0..10, and \"date\" is the stylishness of your date\u0027s clothes. The result getting the table is encoded as an int value with 0\u003dno, 1\u003dmaybe, 2\u003dyes. If either of you is very stylish, 8 or more, then the result is 2 (yes). With the exception that if either of you has style of 2 or less, then the result is 0 (no). Otherwise the result is 1 (maybe). ",
    "examples": "dateFashion(5, 10) → 2 dateFashion(5, 2) → 0 dateFashion(5, 5) → 1\n",
    "template": "public int dateFashion(int you, int date) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "you"
        },
        {
          "type": "int",
          "name": "date"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "5",
            "10"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "5",
            "2"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "5",
            "5"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "3",
            "3"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "10",
            "2"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "2",
            "9"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "9",
            "9"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "10",
            "5"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "2",
            "2"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "3",
            "7"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "2",
            "7"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "6",
            "2"
          ],
          "expectedValue": "0"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "squirrelPlay",
    "description": "The squirrels in Palo Alto spend most of the day playing. In particular, they play if the temperature is between 60 and 90 (inclusive). Unless it is summer, then the upper limit is 100 instead of 90. Given an int temperature and a boolean isSummer, return true if the squirrels play and false otherwise. ",
    "examples": "squirrelPlay(70, false) → true squirrelPlay(95, false) → false squirrelPlay(95, true) → true\n",
    "template": "public boolean squirrelPlay(int temp, boolean isSummer) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "temp"
        },
        {
          "type": "boolean",
          "name": "isSummer"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "70",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "95",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "95",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "90",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "90",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "50",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "50",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "100",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "100",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "105",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "59",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "59",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "60",
            "false"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "caughtSpeeding",
    "description": "You are driving a little too fast, and a police officer stops you. Write code to compute the result, encoded as an int value: 0\u003dno ticket, 1\u003dsmall ticket, 2\u003dbig ticket. If speed is 60 or less, the result is 0. If speed is between 61 and 80 inclusive, the result is 1. If speed is 81 or more, the result is 2. Unless it is your birthday -- on that day, your speed can be 5 higher in all cases. ",
    "examples": "caughtSpeeding(60, false) → 0 caughtSpeeding(65, false) → 1 caughtSpeeding(65, true) → 0\n",
    "template": "public int caughtSpeeding(int speed, boolean isBirthday) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "speed"
        },
        {
          "type": "boolean",
          "name": "isBirthday"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "60",
            "false"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "65",
            "false"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "65",
            "true"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "80",
            "false"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "85",
            "false"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "85",
            "true"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "70",
            "false"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "75",
            "false"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "75",
            "true"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "40",
            "false"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "40",
            "true"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "90",
            "false"
          ],
          "expectedValue": "2"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "sortaSum",
    "description": "Given 2 ints, a and b, return their sum. However, sums in the range 10..19 inclusive, are forbidden, so in that case just return 20. ",
    "examples": "sortaSum(3, 4) → 7 sortaSum(9, 4) → 20 sortaSum(10, 11) → 21\n",
    "template": "public int sortaSum(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "3",
            "4"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "9",
            "4"
          ],
          "expectedValue": "20"
        },
        {
          "inData": [
            "10",
            "11"
          ],
          "expectedValue": "21"
        },
        {
          "inData": [
            "12",
            "-3"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "-3",
            "12"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "4",
            "5"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "4",
            "6"
          ],
          "expectedValue": "20"
        },
        {
          "inData": [
            "14",
            "7"
          ],
          "expectedValue": "21"
        },
        {
          "inData": [
            "14",
            "6"
          ],
          "expectedValue": "20"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "alarmClock",
    "description": "Given a day of the week encoded as 0\u003dSun, 1\u003dMon, 2\u003dTue, ...6\u003dSat, and a boolean indicating if we are on vacation, return a string of the form \"7:00\" indicating when the alarm clock should ring. Weekdays, the alarm should be \"7:00\" and on the weekend it should be \"10:00\". Unless we are on vacation -- then on weekdays it should be \"10:00\" and weekends it should be \"off\". ",
    "examples": "alarmClock(1, false) → \"7:00\" alarmClock(5, false) → \"7:00\" alarmClock(0, false) → \"10:00\"\n",
    "template": "public String alarmClock(int day, boolean vacation) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "day"
        },
        {
          "type": "boolean",
          "name": "vacation"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1",
            "false"
          ],
          "expectedValue": "7:00"
        },
        {
          "inData": [
            "5",
            "false"
          ],
          "expectedValue": "7:00"
        },
        {
          "inData": [
            "0",
            "false"
          ],
          "expectedValue": "10:00"
        },
        {
          "inData": [
            "6",
            "false"
          ],
          "expectedValue": "10:00"
        },
        {
          "inData": [
            "0",
            "true"
          ],
          "expectedValue": "off"
        },
        {
          "inData": [
            "6",
            "true"
          ],
          "expectedValue": "off"
        },
        {
          "inData": [
            "1",
            "true"
          ],
          "expectedValue": "10:00"
        },
        {
          "inData": [
            "3",
            "true"
          ],
          "expectedValue": "10:00"
        },
        {
          "inData": [
            "5",
            "true"
          ],
          "expectedValue": "10:00"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "love6",
    "description": "The number 6 is a truly great number. Given two int values, a and b, return true if either one is 6. Or if their sum or difference is 6. Note: the function Math.abs(num) computes the absolute value of a number. ",
    "examples": "love6(6, 4) → true love6(4, 5) → false love6(1, 5) → true\n",
    "template": "public boolean love6(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "6",
            "4"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "4",
            "5"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1",
            "5"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "6"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "8"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1",
            "7"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "7",
            "5"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "8",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "6",
            "6"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "-6",
            "2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "-4",
            "-10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "-7",
            "1"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "7",
            "-1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "-6",
            "12"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "-2",
            "-4"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "7",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "8",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "3",
            "3"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "3",
            "4"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "in1To10",
    "description": "Given a number n, return true if n is in the range 1..10, inclusive. Unless \"outsideMode\" is true, in which case return true if the number is less or equal to 1, or greater or equal to 10. ",
    "examples": "in1To10(5, false) → true in1To10(11, false) → false in1To10(11, true) → true\n",
    "template": "public boolean in1To10(int n, boolean outsideMode) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        },
        {
          "type": "boolean",
          "name": "outsideMode"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "5",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "11",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "11",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "9",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "9",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "-1",
            "false"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "specialEleven",
    "description": "We\u0027ll say a number is special if it is a multiple of 11 or if it is one more than a multiple of 11. Return true if the given non-negative number is special. Use the % \"mod\" operator -- see \u003ca href\u003d\"/doc/practice/mod-introduction.html\"\u003eIntroduction to Mod\u003c/a\u003e ",
    "examples": "specialEleven(22) → true specialEleven(23) → true specialEleven(24) → false\n",
    "template": "public boolean specialEleven(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "22"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "23"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "24"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "21"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "11"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "12"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "8"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "121"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "122"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "123"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "46"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "49"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "52"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "54"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "55"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "more20",
    "description": "Return true if the given non-negative number is 1 or 2 more than a multiple of 20. See also: \u003ca href\u003d\"/doc/practice/mod-introduction.html\"\u003eIntroduction to Mod\u003c/a\u003e ",
    "examples": "more20(20) → false more20(21) → true more20(22) → true\n",
    "template": "public boolean more20(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "20"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "21"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "22"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "23"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "25"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "30"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "31"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "59"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "60"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "61"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "62"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1020"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1021"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1000"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1001"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "50"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "55"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "40"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "41"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "39"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "42"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "old35",
    "description": "Return true if the given non-negative number is a multiple of 3 or 5, but not both. Use the % \"mod\" operator -- see \u003ca href\u003d\"/doc/practice/mod-introduction.html\"\u003eIntroduction to Mod\u003c/a\u003e ",
    "examples": "old35(3) → true old35(10) → true old35(15) → false\n",
    "template": "public boolean old35(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "3"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "15"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "5"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "9"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "8"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "7"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "6"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "17"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "18"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "29"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "20"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "21"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "22"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "45"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "99"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "less20",
    "description": "Return true if the given non-negative number is 1 or 2 \u003cb\u003eless\u003c/b\u003e than a multiple of 20. So for example 38 and 39 return true, but 40 returns false. See also: \u003ca href\u003d\"/doc/practice/mod-introduction.html\"\u003eIntroduction to Mod\u003c/a\u003e ",
    "examples": "less20(18) → true less20(19) → true less20(20) → false\n",
    "template": "public boolean less20(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "18"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "19"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "20"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "8"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "17"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "23"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "25"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "30"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "31"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "58"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "59"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "60"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "61"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "62"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1017"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1018"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1019"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1020"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1021"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1022"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1023"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "37"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "nearTen",
    "description": "Given a non-negative number \"num\", return true if num is within 2 of a multiple of 10. Note: (a % b) is the remainder of dividing a by b, so (7 % 5) is 2. See also: \u003ca href\u003d\"/doc/practice/mod-introduction.html\"\u003eIntroduction to Mod\u003c/a\u003e ",
    "examples": "nearTen(12) → true nearTen(17) → false nearTen(19) → true\n",
    "template": "public boolean nearTen(int num) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "num"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "12"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "17"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "19"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "31"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "6"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "11"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "21"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "22"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "23"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "54"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "155"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "158"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "teenSum",
    "description": "Given 2 ints, a and b, return their sum. However, \"teen\" values in the range 13..19 inclusive, are extra lucky. So if either value is a teen, just return 19. ",
    "examples": "teenSum(3, 4) → 7 teenSum(10, 13) → 19 teenSum(13, 2) → 19\n",
    "template": "public int teenSum(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "3",
            "4"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "10",
            "13"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "13",
            "2"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "3",
            "19"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "13",
            "13"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "10",
            "10"
          ],
          "expectedValue": "20"
        },
        {
          "inData": [
            "6",
            "14"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "15",
            "2"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "19",
            "19"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "19",
            "20"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "2",
            "18"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "12",
            "4"
          ],
          "expectedValue": "16"
        },
        {
          "inData": [
            "2",
            "20"
          ],
          "expectedValue": "22"
        },
        {
          "inData": [
            "2",
            "17"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "2",
            "16"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "6",
            "7"
          ],
          "expectedValue": "13"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "answerCell",
    "description": "Your cell phone rings. Return true if you should answer it. Normally you answer, except in the morning you only answer if it is your mom calling. In all cases, if you are asleep, you do not answer. ",
    "examples": "answerCell(false, false, false) → true answerCell(false, false, true) → false answerCell(true, false, false) → false\n",
    "template": "public boolean answerCell(boolean isMorning, boolean isMom, boolean isAsleep) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "boolean",
          "name": "isMorning"
        },
        {
          "type": "boolean",
          "name": "isMom"
        },
        {
          "type": "boolean",
          "name": "isAsleep"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "false",
            "false",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "false",
            "false",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "true",
            "false",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "true",
            "true",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "false",
            "true",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "true",
            "true",
            "true"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "teaParty",
    "description": "We are having a party with amounts of tea and candy. Return the int outcome of the party encoded as 0\u003dbad, 1\u003dgood, or 2\u003dgreat. A party is good (1) if both tea and candy are at least 5. However, if either tea or candy is at least double the amount of the other one, the party is great (2). However, in all cases, if either tea or candy is less than 5, the party is always bad (0). ",
    "examples": "teaParty(6, 8) → 1 teaParty(3, 8) → 0 teaParty(20, 6) → 2\n",
    "template": "public int teaParty(int tea, int candy) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "tea"
        },
        {
          "type": "int",
          "name": "candy"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "6",
            "8"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "3",
            "8"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "20",
            "6"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "12",
            "6"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "11",
            "6"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "11",
            "4"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "4",
            "5"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "5",
            "5"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "6",
            "6"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "5",
            "10"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "5",
            "9"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "10",
            "4"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "10",
            "20"
          ],
          "expectedValue": "2"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "fizzString",
    "description": "Given a string str, if the string starts with \"f\" return \"Fizz\". If the string ends with \"b\" return \"Buzz\". If both the \"f\" and \"b\" conditions are true, return \"FizzBuzz\". In all other cases, return the string unchanged. (See also: \u003ca href\u003d\"/doc/practice/fizzbuzz-code.html\"\u003eFizzBuzz Code\u003c/a\u003e) ",
    "examples": "fizzString(\"fig\") → \"Fizz\" fizzString(\"dib\") → \"Buzz\" fizzString(\"fib\") → \"FizzBuzz\"\n",
    "template": "public String fizzString(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "fig"
          ],
          "expectedValue": "Fizz"
        },
        {
          "inData": [
            "dib"
          ],
          "expectedValue": "Buzz"
        },
        {
          "inData": [
            "fib"
          ],
          "expectedValue": "FizzBuzz"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "abc"
        },
        {
          "inData": [
            "fooo"
          ],
          "expectedValue": "Fizz"
        },
        {
          "inData": [
            "booo"
          ],
          "expectedValue": "booo"
        },
        {
          "inData": [
            "ooob"
          ],
          "expectedValue": "Buzz"
        },
        {
          "inData": [
            "fooob"
          ],
          "expectedValue": "FizzBuzz"
        },
        {
          "inData": [
            "f"
          ],
          "expectedValue": "Fizz"
        },
        {
          "inData": [
            "b"
          ],
          "expectedValue": "Buzz"
        },
        {
          "inData": [
            "abcb"
          ],
          "expectedValue": "Buzz"
        },
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "Hello"
        },
        {
          "inData": [
            "Hellob"
          ],
          "expectedValue": "Buzz"
        },
        {
          "inData": [
            "af"
          ],
          "expectedValue": "af"
        },
        {
          "inData": [
            "bf"
          ],
          "expectedValue": "bf"
        },
        {
          "inData": [
            "fb"
          ],
          "expectedValue": "FizzBuzz"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "fizzString2",
    "description": "Given an int n, return the string form of the number followed by \"!\". So the int 6 yields \"6!\". Except if the number is divisible by 3 use \"Fizz\" instead of the number, and if the number is divisible by 5 use \"Buzz\", and if divisible by both 3 and 5, use \"FizzBuzz\". Note: the % \"mod\" operator computes the remainder after division, so 23 % 10 yields 3. What will the remainder be when one number divides evenly into another? (See also: \u003ca href\u003d\"/doc/practice/fizzbuzz-code.html\"\u003eFizzBuzz Code\u003c/a\u003e and \u003ca href\u003d\"/doc/practice/mod-introduction.html\"\u003eIntroduction to Mod\u003c/a\u003e) ",
    "examples": "fizzString2(1) → \"1!\" fizzString2(2) → \"2!\" fizzString2(3) → \"Fizz!\"\n",
    "template": "public String fizzString2(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1"
          ],
          "expectedValue": "1!"
        },
        {
          "inData": [
            "2"
          ],
          "expectedValue": "2!"
        },
        {
          "inData": [
            "3"
          ],
          "expectedValue": "Fizz!"
        },
        {
          "inData": [
            "4"
          ],
          "expectedValue": "4!"
        },
        {
          "inData": [
            "5"
          ],
          "expectedValue": "Buzz!"
        },
        {
          "inData": [
            "6"
          ],
          "expectedValue": "Fizz!"
        },
        {
          "inData": [
            "7"
          ],
          "expectedValue": "7!"
        },
        {
          "inData": [
            "8"
          ],
          "expectedValue": "8!"
        },
        {
          "inData": [
            "9"
          ],
          "expectedValue": "Fizz!"
        },
        {
          "inData": [
            "15"
          ],
          "expectedValue": "FizzBuzz!"
        },
        {
          "inData": [
            "16"
          ],
          "expectedValue": "16!"
        },
        {
          "inData": [
            "18"
          ],
          "expectedValue": "Fizz!"
        },
        {
          "inData": [
            "19"
          ],
          "expectedValue": "19!"
        },
        {
          "inData": [
            "21"
          ],
          "expectedValue": "Fizz!"
        },
        {
          "inData": [
            "44"
          ],
          "expectedValue": "44!"
        },
        {
          "inData": [
            "45"
          ],
          "expectedValue": "FizzBuzz!"
        },
        {
          "inData": [
            "100"
          ],
          "expectedValue": "Buzz!"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "twoAsOne",
    "description": "Given three ints, a b c, return true if it is possible to add two of the ints to get the third. ",
    "examples": "twoAsOne(1, 2, 3) → true twoAsOne(3, 1, 2) → true twoAsOne(3, 2, 2) → false\n",
    "template": "public boolean twoAsOne(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1",
            "2",
            "3"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "3",
            "1",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "3",
            "2",
            "2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "2",
            "3",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "5",
            "3",
            "-2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "5",
            "3",
            "-3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "2",
            "5",
            "3"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "9",
            "5",
            "5"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "9",
            "4",
            "5"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "5",
            "4",
            "9"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "3",
            "3",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "3",
            "3",
            "2"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "inOrder",
    "description": "Given three ints, a b c, return true if b is greater than a, and c is greater than b. However, with the exception that if \"bOk\" is true, b does not need to be greater than a. ",
    "examples": "inOrder(1, 2, 4, false) → true inOrder(1, 2, 1, false) → false inOrder(1, 1, 2, true) → true\n",
    "template": "public boolean inOrder(int a, int b, int c, boolean bOk) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        },
        {
          "type": "boolean",
          "name": "bOk"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1",
            "2",
            "4",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "2",
            "1",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1",
            "1",
            "2",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "3",
            "2",
            "4",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "2",
            "3",
            "4",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "3",
            "2",
            "4",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "4",
            "2",
            "2",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "4",
            "5",
            "2",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "2",
            "4",
            "6",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "7",
            "9",
            "10",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "7",
            "5",
            "6",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "7",
            "5",
            "4",
            "true"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "inOrderEqual",
    "description": "Given three ints, a b c, return true if they are in strict increasing order, such as 2 5 11, or 5 6 7, but not 6 5 7 or 5 5 7. However, with the exception that if \"equalOk\" is true, equality is allowed, such as 5 5 7 or 5 5 5. ",
    "examples": "inOrderEqual(2, 5, 11, false) → true inOrderEqual(5, 7, 6, false) → false inOrderEqual(5, 5, 7, true) → true\n",
    "template": "public boolean inOrderEqual(int a, int b, int c, boolean equalOk) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        },
        {
          "type": "boolean",
          "name": "equalOk"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "2",
            "5",
            "11",
            "false"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "5",
            "7",
            "6",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "5",
            "5",
            "7",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "5",
            "5",
            "7",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "2",
            "5",
            "4",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "3",
            "4",
            "3",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "3",
            "4",
            "4",
            "false"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "3",
            "4",
            "3",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "3",
            "4",
            "4",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "5",
            "5",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "5",
            "5",
            "5",
            "true"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "2",
            "2",
            "1",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "9",
            "2",
            "2",
            "true"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "1",
            "0",
            "true"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "lastDigit",
    "description": "Given three ints, a b c, return true if two or more of them have the same rightmost digit. The ints are non-negative. Note: the % \"mod\" operator computes the remainder, e.g. 17 % 10 is 7. ",
    "examples": "lastDigit(23, 19, 13) → true lastDigit(23, 19, 12) → false lastDigit(23, 19, 3) → true\n",
    "template": "public boolean lastDigit(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "23",
            "19",
            "13"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "23",
            "19",
            "12"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "23",
            "19",
            "3"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "23",
            "19",
            "39"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "2",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1",
            "1",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "2",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "14",
            "25",
            "43"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "14",
            "25",
            "45"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "248",
            "106",
            "1002"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "248",
            "106",
            "1008"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10",
            "11",
            "20"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "11",
            "0"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "lessBy10",
    "description": "Given three ints, a b c, return true if one of them is 10 or more less than one of the others. ",
    "examples": "lessBy10(1, 7, 11) → true lessBy10(1, 7, 10) → false lessBy10(11, 1, 7) → true\n",
    "template": "public boolean lessBy10(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1",
            "7",
            "11"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "7",
            "10"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "11",
            "1",
            "7"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10",
            "7",
            "1"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "-10",
            "2",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "2",
            "11",
            "11"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "3",
            "3",
            "30"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "3",
            "3",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "10",
            "1",
            "11"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10",
            "11",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10",
            "11",
            "2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "3",
            "30",
            "3"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "2",
            "2",
            "-8"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "2",
            "8",
            "12"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "withoutDoubles",
    "description": "Return the sum of two 6-sided dice rolls, each in the range 1..6. However, if noDoubles is true, if the two dice show the same value, increment one die to the next value, wrapping around to 1 if its value was 6. ",
    "examples": "withoutDoubles(2, 3, true) → 5 withoutDoubles(3, 3, true) → 7 withoutDoubles(3, 3, false) → 6\n",
    "template": "public int withoutDoubles(int die1, int die2, boolean noDoubles) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "die1"
        },
        {
          "type": "int",
          "name": "die2"
        },
        {
          "type": "boolean",
          "name": "noDoubles"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "2",
            "3",
            "true"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "3",
            "3",
            "true"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "3",
            "3",
            "false"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "2",
            "3",
            "false"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "5",
            "4",
            "true"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "5",
            "4",
            "false"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "5",
            "5",
            "true"
          ],
          "expectedValue": "11"
        },
        {
          "inData": [
            "5",
            "5",
            "false"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "6",
            "6",
            "true"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "6",
            "6",
            "false"
          ],
          "expectedValue": "12"
        },
        {
          "inData": [
            "1",
            "6",
            "true"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "6",
            "1",
            "false"
          ],
          "expectedValue": "7"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "maxMod5",
    "description": "Given two int values, return whichever value is larger. However if the two values have the same remainder when divided by 5, then the return the smaller value. However, in all cases, if the two values are the same, return 0. Note: the % \"mod\" operator computes the remainder, e.g. 7 % 5 is 2. ",
    "examples": "maxMod5(2, 3) → 3 maxMod5(6, 2) → 6 maxMod5(3, 2) → 3\n",
    "template": "public int maxMod5(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "2",
            "3"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "6",
            "2"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "3",
            "2"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "8",
            "12"
          ],
          "expectedValue": "12"
        },
        {
          "inData": [
            "7",
            "12"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "11",
            "6"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "2",
            "7"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "7",
            "7"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "9",
            "1"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "9",
            "14"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "1",
            "2"
          ],
          "expectedValue": "2"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "redTicket",
    "description": "You have a red lottery ticket showing ints a, b, and c, each of which is 0, 1, or 2. If they are all the value 2, the result is 10. Otherwise if they are all the same, the result is 5. Otherwise so long as both b and c are different from a, the result is 1. Otherwise the result is 0. ",
    "examples": "redTicket(2, 2, 2) → 10 redTicket(2, 2, 1) → 0 redTicket(0, 0, 0) → 5\n",
    "template": "public int redTicket(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "2",
            "2",
            "2"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "2",
            "2",
            "1"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "0",
            "0",
            "0"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "2",
            "0",
            "0"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "1",
            "1",
            "1"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "1",
            "2",
            "1"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "1",
            "2",
            "0"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "0",
            "2",
            "2"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "1",
            "2",
            "2"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "0",
            "2",
            "0"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "1",
            "1",
            "2"
          ],
          "expectedValue": "0"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "greenTicket",
    "description": "You have a green lottery ticket, with ints a, b, and c on it. If the numbers are all different from each other, the result is 0. If all of the numbers are the same, the result is 20. If two of the numbers are the same, the result is 10. ",
    "examples": "greenTicket(1, 2, 3) → 0 greenTicket(2, 2, 2) → 20 greenTicket(1, 1, 2) → 10\n",
    "template": "public int greenTicket(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1",
            "2",
            "3"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "2",
            "2",
            "2"
          ],
          "expectedValue": "20"
        },
        {
          "inData": [
            "1",
            "1",
            "2"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "2",
            "1",
            "1"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "1",
            "2",
            "1"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "3",
            "2",
            "1"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "0",
            "0",
            "0"
          ],
          "expectedValue": "20"
        },
        {
          "inData": [
            "2",
            "0",
            "0"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "0",
            "9",
            "10"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "0",
            "10",
            "0"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "9",
            "9",
            "9"
          ],
          "expectedValue": "20"
        },
        {
          "inData": [
            "9",
            "0",
            "9"
          ],
          "expectedValue": "10"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "blueTicket",
    "description": "You have a blue lottery ticket, with ints a, b, and c on it. This makes three pairs, which we\u0027ll call ab, bc, and ac. Consider the sum of the numbers in each pair. If any pair sums to exactly 10, the result is 10. Otherwise if the ab sum is exactly 10 more than either bc or ac sums, the result is 5. Otherwise the result is 0. ",
    "examples": "blueTicket(9, 1, 0) → 10 blueTicket(9, 2, 0) → 0 blueTicket(6, 1, 4) → 10\n",
    "template": "public int blueTicket(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "9",
            "1",
            "0"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "9",
            "2",
            "0"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "6",
            "1",
            "4"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "6",
            "1",
            "5"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "10",
            "0",
            "0"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "15",
            "0",
            "5"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "5",
            "15",
            "5"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "4",
            "11",
            "1"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "13",
            "2",
            "3"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "8",
            "4",
            "3"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "8",
            "4",
            "2"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "8",
            "4",
            "1"
          ],
          "expectedValue": "0"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "shareDigit",
    "description": "Given two ints, each in the range 10..99, return true if there is a digit that appears in both numbers, such as the 2 in 12 and 23. (Note: division, e.g. n/10, gives the left digit while the % \"mod\" n%10 gives the right digit.) ",
    "examples": "shareDigit(12, 23) → true shareDigit(12, 43) → false shareDigit(12, 44) → false\n",
    "template": "public boolean shareDigit(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "12",
            "23"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "12",
            "43"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "12",
            "44"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "23",
            "12"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "23",
            "39"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "23",
            "19"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "30",
            "90"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "30",
            "91"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "55",
            "55"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "55",
            "44"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Logic-1",
    "title": "sumLimit",
    "description": "Given 2 non-negative ints, a and b, return their sum, so long as the sum has the same number of digits as a. If the sum has more digits than a, just return a without b. (Note: one way to compute the number of digits of a non-negative int n is to convert it to a string with String.valueOf(n) and then check the length of the string.) ",
    "examples": "sumLimit(2, 3) → 5 sumLimit(8, 3) → 8 sumLimit(8, 1) → 9\n",
    "template": "public int sumLimit(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "2",
            "3"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "8",
            "3"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "8",
            "1"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "11",
            "39"
          ],
          "expectedValue": "50"
        },
        {
          "inData": [
            "11",
            "99"
          ],
          "expectedValue": "11"
        },
        {
          "inData": [
            "0",
            "0"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "99",
            "0"
          ],
          "expectedValue": "99"
        },
        {
          "inData": [
            "99",
            "1"
          ],
          "expectedValue": "99"
        },
        {
          "inData": [
            "123",
            "1"
          ],
          "expectedValue": "124"
        },
        {
          "inData": [
            "1",
            "123"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "23",
            "60"
          ],
          "expectedValue": "83"
        },
        {
          "inData": [
            "23",
            "80"
          ],
          "expectedValue": "23"
        },
        {
          "inData": [
            "9000",
            "1"
          ],
          "expectedValue": "9001"
        },
        {
          "inData": [
            "90000000",
            "1"
          ],
          "expectedValue": "90000001"
        },
        {
          "inData": [
            "9000",
            "1000"
          ],
          "expectedValue": "9000"
        }
      ]
    }
  },
  {
    "groupName": "Logic-2",
    "title": "makeBricks",
    "description": "We want to make a row of bricks that is \u003cb\u003egoal\u003c/b\u003e inches long. We have a number of small bricks (1 inch each) and big bricks (5 inches each). Return true if it is possible to make the goal by choosing from the given bricks. This is a little harder than it looks and can be done without any loops. See also: \u003ca href\u003d\"/doc/practice/makebricks-introduction.html\"\u003eIntroduction to MakeBricks\u003c/a\u003e ",
    "examples": "makeBricks(3, 1, 8) → true makeBricks(3, 1, 9) → false makeBricks(3, 2, 10) → true\n",
    "template": "public boolean makeBricks(int small, int big, int goal) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "small"
        },
        {
          "type": "int",
          "name": "big"
        },
        {
          "type": "int",
          "name": "goal"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "3",
            "1",
            "8"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "3",
            "1",
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "3",
            "2",
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "3",
            "2",
            "8"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "3",
            "2",
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "6",
            "1",
            "11"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "6",
            "0",
            "11"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1",
            "4",
            "11"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "3",
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "4",
            "12"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "3",
            "1",
            "7"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "1",
            "7"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "2",
            "1",
            "7"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "7",
            "1",
            "11"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "7",
            "1",
            "8"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "7",
            "1",
            "13"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "43",
            "1",
            "46"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "40",
            "1",
            "46"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "40",
            "2",
            "47"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "40",
            "2",
            "50"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "40",
            "2",
            "52"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "22",
            "2",
            "33"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "2",
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1000000",
            "1000",
            "1000100"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "2",
            "1000000",
            "100003"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "20",
            "0",
            "19"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "20",
            "0",
            "21"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "20",
            "4",
            "51"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "20",
            "4",
            "39"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Logic-2",
    "title": "loneSum",
    "description": "Given 3 int values, a b c, return their sum. However, if one of the values is the same as another of the values, it does not count towards the sum. ",
    "examples": "loneSum(1, 2, 3) → 6 loneSum(3, 2, 3) → 2 loneSum(3, 3, 3) → 0\n",
    "template": "public int loneSum(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1",
            "2",
            "3"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "3",
            "2",
            "3"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "3",
            "3",
            "3"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "9",
            "2",
            "2"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "2",
            "2",
            "9"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "2",
            "9",
            "2"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "2",
            "9",
            "3"
          ],
          "expectedValue": "14"
        },
        {
          "inData": [
            "4",
            "2",
            "3"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "1",
            "3",
            "1"
          ],
          "expectedValue": "3"
        }
      ]
    }
  },
  {
    "groupName": "Logic-2",
    "title": "luckySum",
    "description": "Given 3 int values, a b c, return their sum. However, if one of the values is 13 then it does not count towards the sum and values to its right do not count. So for example, if b is 13, then both b and c do not count. ",
    "examples": "luckySum(1, 2, 3) → 6 luckySum(1, 2, 13) → 3 luckySum(1, 13, 3) → 1\n",
    "template": "public int luckySum(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1",
            "2",
            "3"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "1",
            "2",
            "13"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "1",
            "13",
            "3"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "1",
            "13",
            "13"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "6",
            "5",
            "2"
          ],
          "expectedValue": "13"
        },
        {
          "inData": [
            "13",
            "2",
            "3"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "13",
            "2",
            "13"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "13",
            "13",
            "2"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "9",
            "4",
            "13"
          ],
          "expectedValue": "13"
        },
        {
          "inData": [
            "8",
            "13",
            "2"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "7",
            "2",
            "1"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "3",
            "3",
            "13"
          ],
          "expectedValue": "6"
        }
      ]
    }
  },
  {
    "groupName": "Logic-2",
    "title": "noTeenSum",
    "description": "Given 3 int values, a b c, return their sum. However, if any of the values is a teen -- in the range 13..19 inclusive -- then that value counts as 0, except 15 and 16 do not count as a teens. Write a separate helper \"public int fixTeen(int n) {\"that takes in an int value and returns that value fixed for the teen rule. In this way, you avoid repeating the teen code 3 times (i.e. \"decomposition\"). Define the helper below and at the same indent level as the main noTeenSum(). ",
    "examples": "noTeenSum(). noTeenSum(1, 2, 3) → 6 noTeenSum(2, 13, 1) → 3 noTeenSum(2, 1, 14) → 3\n",
    "template": "public int noTeenSum(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1",
            "2",
            "3"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "2",
            "13",
            "1"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "2",
            "1",
            "14"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "2",
            "1",
            "15"
          ],
          "expectedValue": "18"
        },
        {
          "inData": [
            "2",
            "1",
            "16"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "2",
            "1",
            "17"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "17",
            "1",
            "2"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "2",
            "15",
            "2"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "16",
            "17",
            "18"
          ],
          "expectedValue": "16"
        },
        {
          "inData": [
            "17",
            "18",
            "19"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "15",
            "16",
            "1"
          ],
          "expectedValue": "32"
        },
        {
          "inData": [
            "15",
            "15",
            "19"
          ],
          "expectedValue": "30"
        },
        {
          "inData": [
            "15",
            "19",
            "16"
          ],
          "expectedValue": "31"
        },
        {
          "inData": [
            "5",
            "17",
            "18"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "17",
            "18",
            "16"
          ],
          "expectedValue": "16"
        },
        {
          "inData": [
            "17",
            "19",
            "18"
          ],
          "expectedValue": "0"
        }
      ]
    }
  },
  {
    "groupName": "Logic-2",
    "title": "roundSum",
    "description": "For this problem, we\u0027ll round an int value up to the next multiple of 10 if its rightmost digit is 5 or more, so 15 rounds up to 20. Alternately, round down to the previous multiple of 10 if its rightmost digit is less than 5, so 12 rounds down to 10. Given 3 ints, a b c, return the sum of their rounded values. To avoid code repetition, write a separate helper \"public int round10(int num) {\" and call it 3 times. Write the helper entirely below and at the same indent level as roundSum(). ",
    "examples": "roundSum(). roundSum(16, 17, 18) → 60 roundSum(12, 13, 14) → 30 roundSum(6, 4, 4) → 10\n",
    "template": "public int roundSum(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "16",
            "17",
            "18"
          ],
          "expectedValue": "60"
        },
        {
          "inData": [
            "12",
            "13",
            "14"
          ],
          "expectedValue": "30"
        },
        {
          "inData": [
            "6",
            "4",
            "4"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "4",
            "6",
            "5"
          ],
          "expectedValue": "20"
        },
        {
          "inData": [
            "4",
            "4",
            "6"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "9",
            "4",
            "4"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "0",
            "0",
            "1"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "0",
            "9",
            "0"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "10",
            "10",
            "19"
          ],
          "expectedValue": "40"
        },
        {
          "inData": [
            "20",
            "30",
            "40"
          ],
          "expectedValue": "90"
        },
        {
          "inData": [
            "45",
            "21",
            "30"
          ],
          "expectedValue": "100"
        },
        {
          "inData": [
            "23",
            "11",
            "26"
          ],
          "expectedValue": "60"
        },
        {
          "inData": [
            "23",
            "24",
            "25"
          ],
          "expectedValue": "70"
        },
        {
          "inData": [
            "25",
            "24",
            "25"
          ],
          "expectedValue": "80"
        },
        {
          "inData": [
            "23",
            "24",
            "29"
          ],
          "expectedValue": "70"
        },
        {
          "inData": [
            "11",
            "24",
            "36"
          ],
          "expectedValue": "70"
        },
        {
          "inData": [
            "24",
            "36",
            "32"
          ],
          "expectedValue": "90"
        },
        {
          "inData": [
            "14",
            "12",
            "26"
          ],
          "expectedValue": "50"
        },
        {
          "inData": [
            "12",
            "10",
            "24"
          ],
          "expectedValue": "40"
        }
      ]
    }
  },
  {
    "groupName": "Logic-2",
    "title": "closeFar",
    "description": "Given three ints, a b c, return true if one of b or c is \"close\" (differing from a by at most 1), while the other is \"far\", differing from both other values by 2 or more. Note: Math.abs(num) computes the absolute value of a number. ",
    "examples": "closeFar(1, 2, 10) → true closeFar(1, 2, 3) → false closeFar(4, 1, 3) → true\n",
    "template": "public boolean closeFar(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1",
            "2",
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "2",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "4",
            "1",
            "3"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "4",
            "5",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "4",
            "3",
            "5"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "-1",
            "10",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "-1",
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10",
            "10",
            "8"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10",
            "8",
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "8",
            "9",
            "10"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "8",
            "9",
            "7"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "8",
            "6",
            "9"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Logic-2",
    "title": "blackjack",
    "description": "Given 2 int values greater than 0, return whichever value is nearest to 21 without going over. Return 0 if they both go over. ",
    "examples": "blackjack(19, 21) → 21 blackjack(21, 19) → 21 blackjack(19, 22) → 19\n",
    "template": "public int blackjack(int a, int b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "19",
            "21"
          ],
          "expectedValue": "21"
        },
        {
          "inData": [
            "21",
            "19"
          ],
          "expectedValue": "21"
        },
        {
          "inData": [
            "19",
            "22"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "22",
            "19"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "22",
            "50"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "22",
            "22"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "33",
            "1"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "1",
            "2"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "34",
            "33"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "17",
            "19"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "18",
            "17"
          ],
          "expectedValue": "18"
        },
        {
          "inData": [
            "16",
            "23"
          ],
          "expectedValue": "16"
        },
        {
          "inData": [
            "3",
            "4"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "3",
            "2"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "21",
            "20"
          ],
          "expectedValue": "21"
        }
      ]
    }
  },
  {
    "groupName": "Logic-2",
    "title": "evenlySpaced",
    "description": "Given three ints, a b c, one of them is small, one is medium and one is large. Return true if the three values are evenly spaced, so the difference between small and medium is the same as the difference between medium and large. ",
    "examples": "evenlySpaced(2, 4, 6) → true evenlySpaced(4, 6, 2) → true evenlySpaced(4, 6, 3) → false\n",
    "template": "public boolean evenlySpaced(int a, int b, int c) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "a"
        },
        {
          "type": "int",
          "name": "b"
        },
        {
          "type": "int",
          "name": "c"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "2",
            "4",
            "6"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "4",
            "6",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "4",
            "6",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "6",
            "2",
            "4"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "6",
            "2",
            "8"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "2",
            "2",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "2",
            "2",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "9",
            "10",
            "11"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10",
            "9",
            "11"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "10",
            "9",
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "2",
            "4",
            "4"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "2",
            "2",
            "4"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "3",
            "6",
            "12"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "12",
            "3",
            "6"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Logic-2",
    "title": "makeChocolate",
    "description": "We want make a package of \u003cb\u003egoal\u003c/b\u003e kilos of chocolate. We have small bars (1 kilo each) and big bars (5 kilos each). Return the number of small bars to use, assuming we always use big bars before small bars. Return -1 if it can\u0027t be done. ",
    "examples": "makeChocolate(4, 1, 9) → 4 makeChocolate(4, 1, 10) → -1 makeChocolate(4, 1, 7) → 2\n",
    "template": "public int makeChocolate(int small, int big, int goal) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "small"
        },
        {
          "type": "int",
          "name": "big"
        },
        {
          "type": "int",
          "name": "goal"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "4",
            "1",
            "9"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "4",
            "1",
            "10"
          ],
          "expectedValue": "-1"
        },
        {
          "inData": [
            "4",
            "1",
            "7"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "6",
            "2",
            "7"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "4",
            "1",
            "5"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "4",
            "1",
            "4"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "5",
            "4",
            "9"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "9",
            "3",
            "18"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "3",
            "1",
            "9"
          ],
          "expectedValue": "-1"
        },
        {
          "inData": [
            "1",
            "2",
            "7"
          ],
          "expectedValue": "-1"
        },
        {
          "inData": [
            "1",
            "2",
            "6"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "1",
            "2",
            "5"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "6",
            "1",
            "10"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "6",
            "1",
            "11"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "6",
            "1",
            "12"
          ],
          "expectedValue": "-1"
        },
        {
          "inData": [
            "6",
            "1",
            "13"
          ],
          "expectedValue": "-1"
        },
        {
          "inData": [
            "6",
            "2",
            "10"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "6",
            "2",
            "11"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "6",
            "2",
            "12"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "60",
            "100",
            "550"
          ],
          "expectedValue": "50"
        },
        {
          "inData": [
            "1000",
            "1000000",
            "5000006"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "7",
            "1",
            "12"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "7",
            "1",
            "13"
          ],
          "expectedValue": "-1"
        },
        {
          "inData": [
            "7",
            "2",
            "13"
          ],
          "expectedValue": "3"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "doubleChar",
    "description": "Given a string, return a string where for every char in the original, there are two chars. ",
    "examples": "doubleChar(\"The\") → \"TThhee\" doubleChar(\"AAbb\") → \"AAAAbbbb\" doubleChar(\"Hi-There\") → \"HHii--TThheerree\"\n",
    "template": "public String doubleChar(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "The"
          ],
          "expectedValue": "TThhee"
        },
        {
          "inData": [
            "AAbb"
          ],
          "expectedValue": "AAAAbbbb"
        },
        {
          "inData": [
            "Hi-There"
          ],
          "expectedValue": "HHii--TThheerree"
        },
        {
          "inData": [
            "Word!"
          ],
          "expectedValue": "WWoorrdd!!"
        },
        {
          "inData": [
            "!!"
          ],
          "expectedValue": "!!!!"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": "aa"
        },
        {
          "inData": [
            "."
          ],
          "expectedValue": ".."
        },
        {
          "inData": [
            "aa"
          ],
          "expectedValue": "aaaa"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "countHi",
    "description": "Return the number of times that the string \"hi\" appears anywhere in the given string. ",
    "examples": "countHi(\"abc hi ho\") → 1 countHi(\"ABChi hi\") → 2 countHi(\"hihi\") → 2\n",
    "template": "public int countHi(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abc hi ho"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "ABChi hi"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "hihi"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "hiHIhi"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "h"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "hi"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "Hi is no HI on ahI"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "hiho not HOHIhi"
          ],
          "expectedValue": "2"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "catDog",
    "description": "Return true if the string \"cat\" and \"dog\" appear the same number of times in the given string. ",
    "examples": "catDog(\"catdog\") → true catDog(\"catcat\") → false catDog(\"1cat1cadodog\") → true\n",
    "template": "public boolean catDog(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "catdog"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "catcat"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1cat1cadodog"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "catxxdogxxxdog"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "catxdogxdogxcat"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "catxdogxdogxca"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "dogdogcat"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "dogogcat"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "dog"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "cat"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "ca"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "c"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "countCode",
    "description": "Return the number of times that the string \"code\" appears anywhere in the given string, except we\u0027ll accept any letter for the \u0027d\u0027, so \"cope\" and \"cooe\" count. ",
    "examples": "countCode(\"aaacodebbb\") → 1 countCode(\"codexxcode\") → 2 countCode(\"cozexxcope\") → 2\n",
    "template": "public int countCode(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "aaacodebbb"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "codexxcode"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "cozexxcope"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "cozfxxcope"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "xxcozeyycop"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "cozcop"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "abcxyz"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "code"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "ode"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "c"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "AAcodeBBcoleCCccoreDD"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "AAcodeBBcoleCCccorfDD"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "coAcodeBcoleccoreDD"
          ],
          "expectedValue": "3"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "endOther",
    "description": "Given two strings, return true if either of the strings appears at the very end of the other string, ignoring upper/lower case differences (in other words, the computation should not be \"case sensitive\"). Note: str.toLowerCase() returns the lowercase version of a string. ",
    "examples": "endOther(\"Hiabc\", \"abc\") → true endOther(\"AbC\", \"HiaBc\") → true endOther(\"abc\", \"abXabc\") → true\n",
    "template": "public boolean endOther(String a, String b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "a"
        },
        {
          "type": "String",
          "name": "b"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hiabc",
            "abc"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "AbC",
            "HiaBc"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "abc",
            "abXabc"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "Hiabc",
            "abcd"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "Hiabc",
            "bc"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "Hiabcx",
            "bc"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "abc",
            "abc"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xyz",
            "12xyz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "yz",
            "12xz"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "Z",
            "12xz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "12",
            "12"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "abcXYZ",
            "abcDEF"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "ab",
            "ab12"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "ab",
            "12ab"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "xyzThere",
    "description": "Return true if the given string contains an appearance of \"xyz\" where the xyz is not directly preceeded by a period (.). So \"xxyz\" counts but \"x.xyz\" does not. ",
    "examples": "xyzThere(\"abcxyz\") → true xyzThere(\"abc.xyz\") → false xyzThere(\"xyz.abc\") → true\n",
    "template": "public boolean xyzThere(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abcxyz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "abc.xyz"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xyz.abc"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "abcxy"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xyz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xy"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "abc.xyzxyz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "abc.xxyz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            ".xyz"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "12.xyz"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "12xyz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1.xyz.xyz2.xyz"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "bobThere",
    "description": "Return true if the given string contains a \"bob\" string, but where the middle \u0027o\u0027 char can be any char. ",
    "examples": "bobThere(\"abcbob\") → true bobThere(\"b9b\") → true bobThere(\"bac\") → false\n",
    "template": "public boolean bobThere(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abcbob"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "b9b"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "bac"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "bbb"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "abcdefb"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "123abcbcdbabxyz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "b12"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "b1b"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "b12b1b"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "bbc"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "bbb"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "bb"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "b"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "xyBalance",
    "description": "We\u0027ll say that a String is xy-balanced if for all the \u0027x\u0027 chars in the string, there exists a \u0027y\u0027 char somewhere later in the string. So \"xxy\" is balanced, but \"xyx\" is not. One \u0027y\u0027 can balance multiple \u0027x\u0027s. Return true if the given string is xy-balanced. ",
    "examples": "xyBalance(\"aaxbby\") → true xyBalance(\"aaxbb\") → false xyBalance(\"yaaxbb\") → false\n",
    "template": "public boolean xyBalance(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "aaxbby"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "aaxbb"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "yaaxbb"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "yaaxbby"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xaxxbby"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xaxxbbyx"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xxbxy"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xxbx"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "bbb"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "bxbb"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "bxyb"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xy"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "y"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "yxyxyxyx"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "yxyxyxyxy"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "12xabxxydxyxyzz"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "mixString",
    "description": "Given two strings, \u003cb\u003ea\u003c/b\u003e and \u003cb\u003eb\u003c/b\u003e, create a bigger string made of the first char of a, the first char of b, the second char of a, the second char of b, and so on. Any leftover chars go at the end of the result. ",
    "examples": "mixString(\"abc\", \"xyz\") → \"axbycz\" mixString(\"Hi\", \"There\") → \"HTihere\" mixString(\"xxxx\", \"There\") → \"xTxhxexre\"\n",
    "template": "public String mixString(String a, String b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "a"
        },
        {
          "type": "String",
          "name": "b"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abc",
            "xyz"
          ],
          "expectedValue": "axbycz"
        },
        {
          "inData": [
            "Hi",
            "There"
          ],
          "expectedValue": "HTihere"
        },
        {
          "inData": [
            "xxxx",
            "There"
          ],
          "expectedValue": "xTxhxexre"
        },
        {
          "inData": [
            "xxx",
            "X"
          ],
          "expectedValue": "xXxx"
        },
        {
          "inData": [
            "2/",
            "27 around"
          ],
          "expectedValue": "22/7 around"
        },
        {
          "inData": [
            "",
            "Hello"
          ],
          "expectedValue": "Hello"
        },
        {
          "inData": [
            "Abc",
            ""
          ],
          "expectedValue": "Abc"
        },
        {
          "inData": [
            "",
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "a",
            "b"
          ],
          "expectedValue": "ab"
        },
        {
          "inData": [
            "ax",
            "b"
          ],
          "expectedValue": "abx"
        },
        {
          "inData": [
            "a",
            "bx"
          ],
          "expectedValue": "abx"
        },
        {
          "inData": [
            "So",
            "Long"
          ],
          "expectedValue": "SLoong"
        },
        {
          "inData": [
            "Long",
            "So"
          ],
          "expectedValue": "LSoong"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "repeatEnd",
    "description": "Given a string and an int n, return a string made of n repetitions of the last n characters of the string. You may assume that n is between 0 and the length of the string, inclusive. ",
    "examples": "repeatEnd(\"Hello\", 3) → \"llollollo\" repeatEnd(\"Hello\", 2) → \"lolo\" repeatEnd(\"Hello\", 1) → \"o\"\n",
    "template": "public String repeatEnd(String str, int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello",
            "3"
          ],
          "expectedValue": "llollollo"
        },
        {
          "inData": [
            "Hello",
            "2"
          ],
          "expectedValue": "lolo"
        },
        {
          "inData": [
            "Hello",
            "1"
          ],
          "expectedValue": "o"
        },
        {
          "inData": [
            "Hello",
            "0"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "abc",
            "3"
          ],
          "expectedValue": "abcabcabc"
        },
        {
          "inData": [
            "1234",
            "2"
          ],
          "expectedValue": "3434"
        },
        {
          "inData": [
            "1234",
            "3"
          ],
          "expectedValue": "234234234"
        },
        {
          "inData": [
            "",
            "0"
          ],
          "expectedValue": ""
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "repeatFront",
    "description": "Given a string and an int n, return a string made of the first n characters of the string, followed by the first n-1 characters of the string, and so on. You may assume that n is between 0 and the length of the string, inclusive (i.e. n \u0026gt;\u003d 0 and n \u0026lt;\u003d str.length()). ",
    "examples": "repeatFront(\"Chocolate\", 4) → \"ChocChoChC\" repeatFront(\"Chocolate\", 3) → \"ChoChC\" repeatFront(\"Ice Cream\", 2) → \"IcI\"\n",
    "template": "public String repeatFront(String str, int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Chocolate",
            "4"
          ],
          "expectedValue": "ChocChoChC"
        },
        {
          "inData": [
            "Chocolate",
            "3"
          ],
          "expectedValue": "ChoChC"
        },
        {
          "inData": [
            "Ice Cream",
            "2"
          ],
          "expectedValue": "IcI"
        },
        {
          "inData": [
            "Ice Cream",
            "1"
          ],
          "expectedValue": "I"
        },
        {
          "inData": [
            "Ice Cream",
            "0"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "xyz",
            "3"
          ],
          "expectedValue": "xyzxyx"
        },
        {
          "inData": [
            "",
            "0"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Java",
            "4"
          ],
          "expectedValue": "JavaJavJaJ"
        },
        {
          "inData": [
            "Java",
            "1"
          ],
          "expectedValue": "J"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "repeatSeparator",
    "description": "Given two strings, \u003cb\u003eword\u003c/b\u003e and a separator \u003cb\u003esep\u003c/b\u003e, return a big string made of \u003cb\u003ecount\u003c/b\u003e occurrences of the word, separated by the separator string. ",
    "examples": "repeatSeparator(\"Word\", \"X\", 3) → \"WordXWordXWord\" repeatSeparator(\"This\", \"And\", 2) → \"ThisAndThis\" repeatSeparator(\"This\", \"And\", 1) → \"This\"\n",
    "template": "public String repeatSeparator(String word, String sep, int count) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "word"
        },
        {
          "type": "String",
          "name": "sep"
        },
        {
          "type": "int",
          "name": "count"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Word",
            "X",
            "3"
          ],
          "expectedValue": "WordXWordXWord"
        },
        {
          "inData": [
            "This",
            "And",
            "2"
          ],
          "expectedValue": "ThisAndThis"
        },
        {
          "inData": [
            "This",
            "And",
            "1"
          ],
          "expectedValue": "This"
        },
        {
          "inData": [
            "Hi",
            "-n-",
            "2"
          ],
          "expectedValue": "Hi-n-Hi"
        },
        {
          "inData": [
            "AAA",
            "",
            "1"
          ],
          "expectedValue": "AAA"
        },
        {
          "inData": [
            "AAA",
            "",
            "0"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "A",
            "B",
            "5"
          ],
          "expectedValue": "ABABABABA"
        },
        {
          "inData": [
            "abc",
            "XX",
            "3"
          ],
          "expectedValue": "abcXXabcXXabc"
        },
        {
          "inData": [
            "abc",
            "XX",
            "2"
          ],
          "expectedValue": "abcXXabc"
        },
        {
          "inData": [
            "abc",
            "XX",
            "1"
          ],
          "expectedValue": "abc"
        },
        {
          "inData": [
            "XYZ",
            "a",
            "2"
          ],
          "expectedValue": "XYZaXYZ"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "prefixAgain",
    "description": "Given a string, consider the prefix string made of the first N chars of the string. Does that prefix string appear somewhere else in the string? Assume that the string is not empty and that N is in the range 1..str.length(). ",
    "examples": "prefixAgain(\"abXYabc\", 1) → true prefixAgain(\"abXYabc\", 2) → true prefixAgain(\"abXYabc\", 3) → false\n",
    "template": "public boolean prefixAgain(String str, int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abXYabc",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "abXYabc",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "abXYabc",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xyzxyxyxy",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xyzxyxyxy",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "Hi12345Hi6789Hi10",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "Hi12345Hi6789Hi10",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "Hi12345Hi6789Hi10",
            "3"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "Hi12345Hi6789Hi10",
            "4"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "a",
            "1"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "aa",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "ab",
            "1"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "xyzMiddle",
    "description": "Given a string, does \"xyz\" appear in the middle of the string? To define middle, we\u0027ll say that the number of chars to the left and right of the \"xyz\" must differ by at most one. This problem is harder than it looks. ",
    "examples": "xyzMiddle(\"AAxyzBB\") → true xyzMiddle(\"AxyzBB\") → true xyzMiddle(\"AxyzBBB\") → false\n",
    "template": "public boolean xyzMiddle(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "AAxyzBB"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "AxyzBB"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "AxyzBBB"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "AxyzBBBB"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "AAAxyzB"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "AAAxyzBB"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "AAAAxyzBB"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "AAAAAxyzBBB"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1x345xyz12x4"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xyzAxyzBBB"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xyzAxyzBxyz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xyzxyzAxyzBxyzxyz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xyzxyzxyzBxyzxyz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xyzxyzAxyzxyzxyz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xyzxyzAxyzxyzxy"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "AxyzxyzBB"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xy"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xyz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xyzz"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "getSandwich",
    "description": "A sandwich is two pieces of bread with something in between. Return the string that is between the first and last appearance of \"bread\" in the given string, or return the empty string \"\" if there are not two pieces of bread. ",
    "examples": "getSandwich(\"breadjambread\") → \"jam\" getSandwich(\"xxbreadjambreadyy\") → \"jam\" getSandwich(\"xxbreadyy\") → \"\"\n",
    "template": "public String getSandwich(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "breadjambread"
          ],
          "expectedValue": "jam"
        },
        {
          "inData": [
            "xxbreadjambreadyy"
          ],
          "expectedValue": "jam"
        },
        {
          "inData": [
            "xxbreadyy"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "xxbreadbreadjambreadyy"
          ],
          "expectedValue": "breadjam"
        },
        {
          "inData": [
            "breadAbread"
          ],
          "expectedValue": "A"
        },
        {
          "inData": [
            "breadbread"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "abcbreaz"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "xyz"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "breadbreaxbread"
          ],
          "expectedValue": "breax"
        },
        {
          "inData": [
            "breaxbreadybread"
          ],
          "expectedValue": "y"
        },
        {
          "inData": [
            "breadbreadbreadbread"
          ],
          "expectedValue": "breadbread"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "sameStarChar",
    "description": "Returns true if for every \u0027*\u0027 (star) in the string, if there are chars both immediately before and after the star, they are the same. ",
    "examples": "sameStarChar(\"xy*yzz\") → true sameStarChar(\"xy*zzz\") → false sameStarChar(\"*xa*az\") → true\n",
    "template": "public boolean sameStarChar(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "xy*yzz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xy*zzz"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "*xa*az"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "*xa*bz"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "*xa*a*"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "*xa*a*a"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "*xa*a*b"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "*12*2*2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "12*2*3*"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "abcDEF"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "XY*YYYY*Z*"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "XY*YYYY*Y*"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "12*2*3*"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "*"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "**"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "oneTwo",
    "description": "Given a string, compute a new string by moving the first char to come after the next two chars, so \"abc\" yields \"bca\". Repeat this process for each subsequent group of 3 chars, so \"abcdef\" yields \"bcaefd\". Ignore any group of fewer than 3 chars at the end. ",
    "examples": "oneTwo(\"abc\") → \"bca\" oneTwo(\"tca\") → \"cat\" oneTwo(\"tcagdo\") → \"catdog\"\n",
    "template": "public String oneTwo(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "bca"
        },
        {
          "inData": [
            "tca"
          ],
          "expectedValue": "cat"
        },
        {
          "inData": [
            "tcagdo"
          ],
          "expectedValue": "catdog"
        },
        {
          "inData": [
            "chocolate"
          ],
          "expectedValue": "hocolctea"
        },
        {
          "inData": [
            "1234567890"
          ],
          "expectedValue": "231564897"
        },
        {
          "inData": [
            "xabxabxabxabxabxabxab"
          ],
          "expectedValue": "abxabxabxabxabxabxabx"
        },
        {
          "inData": [
            "abcdefx"
          ],
          "expectedValue": "bcaefd"
        },
        {
          "inData": [
            "abcdefxy"
          ],
          "expectedValue": "bcaefd"
        },
        {
          "inData": [
            "abcdefxyz"
          ],
          "expectedValue": "bcaefdyzx"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "xy"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "xyz"
          ],
          "expectedValue": "yzx"
        },
        {
          "inData": [
            "abcdefghijklkmnopqrstuvwxyz1234567890"
          ],
          "expectedValue": "bcaefdhigkljmnkpqostrvwuyzx231564897"
        },
        {
          "inData": [
            "abcdefghijklkmnopqrstuvwxyz123456789"
          ],
          "expectedValue": "bcaefdhigkljmnkpqostrvwuyzx231564897"
        },
        {
          "inData": [
            "abcdefghijklkmnopqrstuvwxyz12345678"
          ],
          "expectedValue": "bcaefdhigkljmnkpqostrvwuyzx231564"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "zipZap",
    "description": "Look for patterns like \"zip\" and \"zap\" in the string -- length-3, starting with \u0027z\u0027 and ending with \u0027p\u0027. Return a string where for all such words, the middle letter is gone, so \"zipXzap\" yields \"zpXzp\". ",
    "examples": "zipZap(\"zipXzap\") → \"zpXzp\" zipZap(\"zopzop\") → \"zpzp\" zipZap(\"zzzopzop\") → \"zzzpzp\"\n",
    "template": "public String zipZap(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "zipXzap"
          ],
          "expectedValue": "zpXzp"
        },
        {
          "inData": [
            "zopzop"
          ],
          "expectedValue": "zpzp"
        },
        {
          "inData": [
            "zzzopzop"
          ],
          "expectedValue": "zzzpzp"
        },
        {
          "inData": [
            "zibzap"
          ],
          "expectedValue": "zibzp"
        },
        {
          "inData": [
            "zip"
          ],
          "expectedValue": "zp"
        },
        {
          "inData": [
            "zi"
          ],
          "expectedValue": "zi"
        },
        {
          "inData": [
            "z"
          ],
          "expectedValue": "z"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "zzp"
          ],
          "expectedValue": "zp"
        },
        {
          "inData": [
            "abcppp"
          ],
          "expectedValue": "abcppp"
        },
        {
          "inData": [
            "azbcppp"
          ],
          "expectedValue": "azbcppp"
        },
        {
          "inData": [
            "azbcpzpp"
          ],
          "expectedValue": "azbcpzp"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "starOut",
    "description": "Return a version of the given string, where for every star (*) in the string the star and the chars immediately to its left and right are gone. So \"ab*cd\" yields \"ad\" and \"ab**cd\" also yields \"ad\". ",
    "examples": "starOut(\"ab*cd\") → \"ad\" starOut(\"ab**cd\") → \"ad\" starOut(\"sm*eilly\") → \"silly\"\n",
    "template": "public String starOut(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "ab*cd"
          ],
          "expectedValue": "ad"
        },
        {
          "inData": [
            "ab**cd"
          ],
          "expectedValue": "ad"
        },
        {
          "inData": [
            "sm*eilly"
          ],
          "expectedValue": "silly"
        },
        {
          "inData": [
            "sm*eil*ly"
          ],
          "expectedValue": "siy"
        },
        {
          "inData": [
            "sm**eil*ly"
          ],
          "expectedValue": "siy"
        },
        {
          "inData": [
            "sm***eil*ly"
          ],
          "expectedValue": "siy"
        },
        {
          "inData": [
            "stringy*"
          ],
          "expectedValue": "string"
        },
        {
          "inData": [
            "*stringy"
          ],
          "expectedValue": "tringy"
        },
        {
          "inData": [
            "*str*in*gy"
          ],
          "expectedValue": "ty"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "abc"
        },
        {
          "inData": [
            "a*bc"
          ],
          "expectedValue": "c"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "ab"
        },
        {
          "inData": [
            "a*b"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": "a"
        },
        {
          "inData": [
            "a*"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "*a"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "*"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "plusOut",
    "description": "Given a string and a non-empty \u003cb\u003eword\u003c/b\u003e string, return a version of the original String where all chars have been replaced by pluses (\"+\"), except for appearances of the word string which are preserved unchanged. ",
    "examples": "plusOut(\"12xy34\", \"xy\") → \"++xy++\" plusOut(\"12xy34\", \"1\") → \"1+++++\" plusOut(\"12xy34xyabcxy\", \"xy\") → \"++xy++xy+++xy\"\n",
    "template": "public String plusOut(String str, String word) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "String",
          "name": "word"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "12xy34",
            "xy"
          ],
          "expectedValue": "++xy++"
        },
        {
          "inData": [
            "12xy34",
            "1"
          ],
          "expectedValue": "1+++++"
        },
        {
          "inData": [
            "12xy34xyabcxy",
            "xy"
          ],
          "expectedValue": "++xy++xy+++xy"
        },
        {
          "inData": [
            "abXYabcXYZ",
            "ab"
          ],
          "expectedValue": "ab++ab++++"
        },
        {
          "inData": [
            "abXYabcXYZ",
            "abc"
          ],
          "expectedValue": "++++abc+++"
        },
        {
          "inData": [
            "abXYabcXYZ",
            "XY"
          ],
          "expectedValue": "++XY+++XY+"
        },
        {
          "inData": [
            "abXYxyzXYZ",
            "XYZ"
          ],
          "expectedValue": "+++++++XYZ"
        },
        {
          "inData": [
            "--++ab",
            "++"
          ],
          "expectedValue": "++++++"
        },
        {
          "inData": [
            "aaxxxxbb",
            "xx"
          ],
          "expectedValue": "++xxxx++"
        },
        {
          "inData": [
            "123123",
            "3"
          ],
          "expectedValue": "++3++3"
        }
      ]
    }
  },
  {
    "groupName": "String-2",
    "title": "wordEnds",
    "description": "Given a string and a non-empty \u003cb\u003eword\u003c/b\u003e string, return a string made of each char just before and just after every appearance of the word in the string. Ignore cases where there is no char before or after the word, and a char may be included twice if it is between two words. ",
    "examples": "wordEnds(\"abcXY123XYijk\", \"XY\") → \"c13i\" wordEnds(\"XY123XY\", \"XY\") → \"13\" wordEnds(\"XY1XY\", \"XY\") → \"11\"\n",
    "template": "public String wordEnds(String str, String word) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "String",
          "name": "word"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abcXY123XYijk",
            "XY"
          ],
          "expectedValue": "c13i"
        },
        {
          "inData": [
            "XY123XY",
            "XY"
          ],
          "expectedValue": "13"
        },
        {
          "inData": [
            "XY1XY",
            "XY"
          ],
          "expectedValue": "11"
        },
        {
          "inData": [
            "XYXY",
            "XY"
          ],
          "expectedValue": "XY"
        },
        {
          "inData": [
            "XY",
            "XY"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Hi",
            "XY"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "",
            "XY"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "abc1xyz1i1j",
            "1"
          ],
          "expectedValue": "cxziij"
        },
        {
          "inData": [
            "abc1xyz1",
            "1"
          ],
          "expectedValue": "cxz"
        },
        {
          "inData": [
            "abc1xyz11",
            "1"
          ],
          "expectedValue": "cxz11"
        },
        {
          "inData": [
            "abc1xyz1abc",
            "abc"
          ],
          "expectedValue": "11"
        },
        {
          "inData": [
            "abc1xyz1abc",
            "b"
          ],
          "expectedValue": "acac"
        },
        {
          "inData": [
            "abc1abc1abc",
            "abc"
          ],
          "expectedValue": "1111"
        }
      ]
    }
  },
  {
    "groupName": "String-3",
    "title": "countYZ",
    "description": "Given a string, count the number of words ending in \u0027y\u0027 or \u0027z\u0027 -- so the \u0027y\u0027 in \"heavy\" and the \u0027z\u0027 in \"fez\" count, but not the \u0027y\u0027 in \"yellow\" (not case sensitive). We\u0027ll say that a y or z is at the end of a word if there is not an alphabetic letter immediately following it. (Note: Character.isLetter(char) tests if a char is an alphabetic letter.) ",
    "examples": "countYZ(\"fez day\") → 2 countYZ(\"day fez\") → 2 countYZ(\"day fyyyz\") → 2\n",
    "template": "public int countYZ(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "fez day"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "day fez"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "day fyyyz"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "day yak"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "day:yak"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "!!day--yaz!!"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "yak zak"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "DAY abc XYZ"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "aaz yyz my"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "y2bz"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "zxyx"
          ],
          "expectedValue": "0"
        }
      ]
    }
  },
  {
    "groupName": "String-3",
    "title": "withoutString",
    "description": "Given two strings, \u003cb\u003ebase\u003c/b\u003e and \u003cb\u003eremove\u003c/b\u003e, return a version of the base string where all instances of the remove string have been removed (not case sensitive). You may assume that the remove string is length 1 or more. Remove only non-overlapping instances, so with \"xxx\" removing \"xx\" leaves \"x\". ",
    "examples": "withoutString(\"Hello there\", \"llo\") → \"He there\" withoutString(\"Hello there\", \"e\") → \"Hllo thr\" withoutString(\"Hello there\", \"x\") → \"Hello there\"\n",
    "template": "public String withoutString(String base, String remove) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "base"
        },
        {
          "type": "String",
          "name": "remove"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "Hello there",
            "llo"
          ],
          "expectedValue": "He there"
        },
        {
          "inData": [
            "Hello there",
            "e"
          ],
          "expectedValue": "Hllo thr"
        },
        {
          "inData": [
            "Hello there",
            "x"
          ],
          "expectedValue": "Hello there"
        },
        {
          "inData": [
            "This is a FISH",
            "IS"
          ],
          "expectedValue": "Th  a FH"
        },
        {
          "inData": [
            "THIS is a FISH",
            "is"
          ],
          "expectedValue": "TH  a FH"
        },
        {
          "inData": [
            "THIS is a FISH",
            "iS"
          ],
          "expectedValue": "TH  a FH"
        },
        {
          "inData": [
            "abxxxxab",
            "xx"
          ],
          "expectedValue": "abab"
        },
        {
          "inData": [
            "abxxxab",
            "xx"
          ],
          "expectedValue": "abxab"
        },
        {
          "inData": [
            "abxxxab",
            "x"
          ],
          "expectedValue": "abab"
        },
        {
          "inData": [
            "xxx",
            "x"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "xxx",
            "xx"
          ],
          "expectedValue": "x"
        },
        {
          "inData": [
            "xyzzy",
            "Y"
          ],
          "expectedValue": "xzz"
        },
        {
          "inData": [
            "",
            "x"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "abcabc",
            "b"
          ],
          "expectedValue": "acac"
        },
        {
          "inData": [
            "AA22bb",
            "2"
          ],
          "expectedValue": "AAbb"
        },
        {
          "inData": [
            "1111",
            "1"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "1111",
            "11"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "MkjtMkx",
            "Mk"
          ],
          "expectedValue": "jtx"
        },
        {
          "inData": [
            "Hi HoHo",
            "Ho"
          ],
          "expectedValue": "Hi "
        }
      ]
    }
  },
  {
    "groupName": "String-3",
    "title": "equalIsNot",
    "description": "Given a string, return true if the number of appearances of \"is\" anywhere in the string is equal to the number of appearances of \"not\" anywhere in the string (case sensitive). ",
    "examples": "equalIsNot(\"This is not\") → false equalIsNot(\"This is notnot\") → true equalIsNot(\"noisxxnotyynotxisi\") → true\n",
    "template": "public boolean equalIsNot(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "This is not"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "This is notnot"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "noisxxnotyynotxisi"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "noisxxnotyynotxsi"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xxxyyyzzzintint"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "isisnotnot"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "isisnotno7Not"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "isnotis"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "mis3notpotbotis"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "String-3",
    "title": "gHappy",
    "description": "We\u0027ll say that a lowercase \u0027g\u0027 in a string is \"happy\" if there is another \u0027g\u0027 immediately to its left or right. Return true if all the g\u0027s in the given string are happy. ",
    "examples": "gHappy(\"xxggxx\") → true gHappy(\"xxgxx\") → false gHappy(\"xxggyygxx\") → false\n",
    "template": "public boolean gHappy(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "xxggxx"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xxgxx"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xxggyygxx"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "g"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "gg"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xxgggxyz"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "xxgggxyg"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "xxgggxygg"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "mgm"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "mggm"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "yyygggxyy"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "String-3",
    "title": "countTriple",
    "description": "We\u0027ll say that a \"triple\" in a string is a char appearing three times in a row. Return the number of triples in the given string. The triples may overlap. ",
    "examples": "countTriple(\"abcXXXabc\") → 1 countTriple(\"xxxabyyyycd\") → 3 countTriple(\"a\") → 0\n",
    "template": "public int countTriple(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abcXXXabc"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "xxxabyyyycd"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "XXXabc"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "XXXXabc"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "XXXXXabc"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "222abyyycdXXX"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "abYYYabXXXXXab"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "abYYXabXXYXXab"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "abYYXabXXYXXab"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "122abhhh2"
          ],
          "expectedValue": "1"
        }
      ]
    }
  },
  {
    "groupName": "String-3",
    "title": "sumDigits",
    "description": "Given a string, return the sum of the digits 0-9 that appear in the string, ignoring all other characters. Return 0 if there are no digits in the string. (Note: Character.isDigit(char) tests if a char is one of the chars \u00270\u0027, \u00271\u0027, .. \u00279\u0027. Integer.parseInt(string) converts a string to an int.) ",
    "examples": "sumDigits(\"aa1bc2d3\") → 6 sumDigits(\"aa11b33\") → 8 sumDigits(\"Chocolate\") → 0\n",
    "template": "public int sumDigits(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "aa1bc2d3"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "aa11b33"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "Chocolate"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "5hoco1a1e"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "123abc123"
          ],
          "expectedValue": "12"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "X1z9b2"
          ],
          "expectedValue": "12"
        },
        {
          "inData": [
            "5432a"
          ],
          "expectedValue": "14"
        }
      ]
    }
  },
  {
    "groupName": "String-3",
    "title": "sameEnds",
    "description": "Given a string, return the longest substring that appears at both the beginning and end of the string without overlapping. For example, sameEnds(\"abXab\") is \"ab\". ",
    "examples": "sameEnds(\"abXab\") is \"ab\". sameEnds(\"abXYab\") → \"ab\" sameEnds(\"xx\") → \"x\" sameEnds(\"xxx\") → \"x\"\n",
    "template": "public String sameEnds(String string) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "string"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abXYab"
          ],
          "expectedValue": "ab"
        },
        {
          "inData": [
            "xx"
          ],
          "expectedValue": "x"
        },
        {
          "inData": [
            "xxx"
          ],
          "expectedValue": "x"
        },
        {
          "inData": [
            "xxxx"
          ],
          "expectedValue": "xx"
        },
        {
          "inData": [
            "javaXYZjava"
          ],
          "expectedValue": "java"
        },
        {
          "inData": [
            "javajava"
          ],
          "expectedValue": "java"
        },
        {
          "inData": [
            "xavaXYZjava"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "Hello! and Hello!"
          ],
          "expectedValue": "Hello!"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "abcb"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "mymmy"
          ],
          "expectedValue": "my"
        }
      ]
    }
  },
  {
    "groupName": "String-3",
    "title": "mirrorEnds",
    "description": "Given a string, look for a mirror image (backwards) string at both the beginning and end of the given string. In other words, zero or more characters at the very begining of the given string, and at the very end of the string in reverse order (possibly overlapping). For example, the string \"abXYZba\" has the mirror end \"ab\". ",
    "examples": "mirrorEnds(\"abXYZba\") → \"ab\" mirrorEnds(\"abca\") → \"a\" mirrorEnds(\"aba\") → \"aba\"\n",
    "template": "public String mirrorEnds(String string) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "string"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abXYZba"
          ],
          "expectedValue": "ab"
        },
        {
          "inData": [
            "abca"
          ],
          "expectedValue": "a"
        },
        {
          "inData": [
            "aba"
          ],
          "expectedValue": "aba"
        },
        {
          "inData": [
            "abab"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "xxx"
          ],
          "expectedValue": "xxx"
        },
        {
          "inData": [
            "xxYxx"
          ],
          "expectedValue": "xxYxx"
        },
        {
          "inData": [
            "Hi and iH"
          ],
          "expectedValue": "Hi "
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "x"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "123and then 321"
          ],
          "expectedValue": "123"
        },
        {
          "inData": [
            "band andab"
          ],
          "expectedValue": "ba"
        }
      ]
    }
  },
  {
    "groupName": "String-3",
    "title": "maxBlock",
    "description": "Given a string, return the length of the largest \"block\" in the string. A block is a run of adjacent chars that are the same. ",
    "examples": "maxBlock(\"hoopla\") → 2 maxBlock(\"abbCCCddBBBxx\") → 3 maxBlock(\"\") → 0\n",
    "template": "public int maxBlock(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "hoopla"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "abbCCCddBBBxx"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "xyz"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "xxyz"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "xyzz"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "abbbcbbbxbbbx"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "XXBBBbbxx"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "XXBBBBbbxx"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "XXBBBbbxxXXXX"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "XX2222BBBbbXX2222"
          ],
          "expectedValue": "4"
        }
      ]
    }
  },
  {
    "groupName": "String-3",
    "title": "sumNumbers",
    "description": "Given a string, return the sum of the numbers appearing in the string, ignoring all other characters. A number is a series of 1 or more digit chars in a row. (Note: Character.isDigit(char) tests if a char is one of the chars \u00270\u0027, \u00271\u0027, .. \u00279\u0027. Integer.parseInt(string) converts a string to an int.) ",
    "examples": "sumNumbers(\"abc123xyz\") → 123 sumNumbers(\"aa11b33\") → 44 sumNumbers(\"7 11\") → 18\n",
    "template": "public int sumNumbers(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abc123xyz"
          ],
          "expectedValue": "123"
        },
        {
          "inData": [
            "aa11b33"
          ],
          "expectedValue": "44"
        },
        {
          "inData": [
            "7 11"
          ],
          "expectedValue": "18"
        },
        {
          "inData": [
            "Chocolate"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "5hoco1a1e"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "5$$1;;1!!"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "a1234bb11"
          ],
          "expectedValue": "1245"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "a22bbb3"
          ],
          "expectedValue": "25"
        }
      ]
    }
  },
  {
    "groupName": "String-3",
    "title": "notReplace",
    "description": "Given a string, return a string where every appearance of the lowercase word \"is\" has been replaced with \"is not\". The word \"is\" should not be immediately preceeded or followed by a letter -- so for example the \"is\" in \"this\" does not count. (Note: Character.isLetter(char) tests if a char is a letter.) ",
    "examples": "notReplace(\"is test\") → \"is not test\" notReplace(\"is-is\") → \"is not-is not\" notReplace(\"This is right\") → \"This is not right\"\n",
    "template": "public String notReplace(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "is test"
          ],
          "expectedValue": "is not test"
        },
        {
          "inData": [
            "is-is"
          ],
          "expectedValue": "is not-is not"
        },
        {
          "inData": [
            "This is right"
          ],
          "expectedValue": "This is not right"
        },
        {
          "inData": [
            "This is isabell"
          ],
          "expectedValue": "This is not isabell"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "is"
          ],
          "expectedValue": "is not"
        },
        {
          "inData": [
            "isis"
          ],
          "expectedValue": "isis"
        },
        {
          "inData": [
            "Dis is bliss is"
          ],
          "expectedValue": "Dis is not bliss is not"
        },
        {
          "inData": [
            "is his"
          ],
          "expectedValue": "is not his"
        },
        {
          "inData": [
            "xis yis"
          ],
          "expectedValue": "xis yis"
        },
        {
          "inData": [
            "AAAis is"
          ],
          "expectedValue": "AAAis is not"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "countEvens",
    "description": "Return the number of even ints in the given array. Note: the % \"mod\" operator computes the remainder, e.g. 5 % 2 is 1. ",
    "examples": "countEvens({2, 1, 2, 3, 4}) → 3 countEvens({2, 2, 0}) → 3 countEvens({1, 3, 5}) → 0\n",
    "template": "public int countEvens(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{2, 1, 2, 3, 4}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{2, 2, 0}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{1, 3, 5}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{11, 9, 0, 1}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{2, 11, 9, 0}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{2}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{2, 5, 12}"
          ],
          "expectedValue": "2"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "bigDiff",
    "description": "Given an array length 1 or more of ints, return the difference between the largest and smallest values in the array. Note: the built-in Math.min(v1, v2) and Math.max(v1, v2) methods return the smaller or larger of two values. ",
    "examples": "bigDiff({10, 3, 5, 6}) → 7 bigDiff({7, 2, 10, 9}) → 8 bigDiff({2, 10, 7, 2}) → 8\n",
    "template": "public int bigDiff(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{10, 3, 5, 6}"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "{7, 2, 10, 9}"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "{2, 10, 7, 2}"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "{2, 10}"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "{10, 2}"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "{10, 0}"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "{2, 3}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{2, 2}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{2}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{5, 1, 6, 1, 9, 9}"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "{7, 6, 8, 5}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{7, 7, 6, 8, 5, 5, 6}"
          ],
          "expectedValue": "3"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "centeredAverage",
    "description": "Return the \"centered\" average of an array of ints, which we\u0027ll say is the mean average of the values, except ignoring the largest and smallest values in the array. If there are multiple copies of the smallest value, ignore just one copy, and likewise for the largest value. Use int division to produce the final average. You may assume that the array is length 3 or more. ",
    "examples": "centeredAverage({1, 2, 3, 4, 100}) → 3 centeredAverage({1, 1, 5, 5, 10, 8, 7}) → 5 centeredAverage({-10, -4, -2, -4, -2, 0}) → -3\n",
    "template": "public int centeredAverage(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3, 4, 100}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{1, 1, 5, 5, 10, 8, 7}"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "{-10, -4, -2, -4, -2, 0}"
          ],
          "expectedValue": "-3"
        },
        {
          "inData": [
            "{5, 3, 4, 6, 2}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{5, 3, 4, 0, 100}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{100, 0, 5, 3, 4}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{4, 0, 100}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{0, 2, 3, 4, 100}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{1, 1, 100}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{7, 7, 7}"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "{1, 7, 8}"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "{1, 1, 99, 99}"
          ],
          "expectedValue": "50"
        },
        {
          "inData": [
            "{1000, 0, 1, 99}"
          ],
          "expectedValue": "50"
        },
        {
          "inData": [
            "{4, 4, 4, 4, 5}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{4, 4, 4, 1, 5}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{6, 4, 8, 12, 3}"
          ],
          "expectedValue": "6"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "sum13",
    "description": "Return the sum of the numbers in the array, returning 0 for an empty array. Except the number 13 is very unlucky, so it does not count and numbers that come immediately after a 13 also do not count. ",
    "examples": "sum13({1, 2, 2, 1}) → 6 sum13({1, 1}) → 2 sum13({1, 2, 2, 1, 13}) → 6\n",
    "template": "public int sum13(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 2, 1}"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "{1, 1}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 2, 2, 1, 13}"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "{1, 2, 13, 2, 1, 13}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{13, 1, 2, 13, 2, 1, 13}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{13}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{13, 13}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{13, 0, 13}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{13, 1, 13}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{5, 7, 2}"
          ],
          "expectedValue": "14"
        },
        {
          "inData": [
            "{5, 13, 2}"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "{0}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{13, 0}"
          ],
          "expectedValue": "0"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "sum67",
    "description": "Return the sum of the numbers in the array, except ignore sections of numbers starting with a 6 and extending to the next 7 (every 6 will be followed by at least one 7). Return 0 for no numbers. ",
    "examples": "sum67({1, 2, 2}) → 5 sum67({1, 2, 2, 6, 99, 99, 7}) → 5 sum67({1, 1, 6, 7, 2}) → 4\n",
    "template": "public int sum67(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 2}"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "{1, 2, 2, 6, 99, 99, 7}"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "{1, 1, 6, 7, 2}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{1, 6, 2, 2, 7, 1, 6, 99, 99, 7}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 6, 2, 6, 2, 7, 1, 6, 99, 99, 7}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{2, 7, 6, 2, 6, 7, 2, 7}"
          ],
          "expectedValue": "18"
        },
        {
          "inData": [
            "{2, 7, 6, 2, 6, 2, 7}"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "{1, 6, 7, 7}"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "{6, 7, 1, 6, 7, 7}"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "{6, 8, 1, 6, 7}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{6, 7, 11}"
          ],
          "expectedValue": "11"
        },
        {
          "inData": [
            "{11, 6, 7, 11}"
          ],
          "expectedValue": "22"
        },
        {
          "inData": [
            "{2, 2, 6, 7, 7}"
          ],
          "expectedValue": "11"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "has22",
    "description": "Given an array of ints, return true if the array contains a 2 next to a 2 somewhere. ",
    "examples": "has22({1, 2, 2}) → true has22({1, 2, 1, 2}) → false has22({2, 1, 2}) → false\n",
    "template": "public boolean has22(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 1, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 1, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 2, 1, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 3, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 3, 2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 3, 2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{4, 2, 4, 2, 2, 5}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 3, 2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{5, 2, 5, 2}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "lucky13",
    "description": "Given an array of ints, return true if the array contains no 1\u0027s and no 3\u0027s. ",
    "examples": "lucky13({0, 2, 4}) → true lucky13({1, 2, 3}) → false lucky13({1, 2, 4}) → false\n",
    "template": "public boolean lucky13(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{0, 2, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 7, 2, 8}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 7, 1, 8}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 7, 2, 8}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 7, 2, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "sum28",
    "description": "Given an array of ints, return true if the sum of all the 2\u0027s in the array is exactly 8. ",
    "examples": "sum28({2, 3, 2, 2, 4, 2}) → true sum28({2, 3, 2, 2, 4, 2, 2}) → false sum28({1, 2, 3, 4}) → false\n",
    "template": "public boolean sum28(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{2, 3, 2, 2, 4, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 3, 2, 2, 4, 2, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 2, 2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 2, 2, 2, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{8}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 2, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 2, 2, 2, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 2, 1, 2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{5, 2, 2, 2, 4, 2}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "more14",
    "description": "Given an array of ints, return true if the number of 1\u0027s is greater than the number of 4\u0027s ",
    "examples": "more14({1, 4, 1}) → true more14({1, 4, 1, 4}) → false more14({1, 1}) → true\n",
    "template": "public boolean more14(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 4, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 4, 1, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 6, 6}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{6, 1, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 6, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1, 4, 4, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 6, 4, 4, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{4, 1, 4, 6}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{4, 1, 4, 6, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 4, 1, 4, 1, 6}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "fizzArray",
    "description": "Given a number n, create and return a new int array of length n, containing the numbers 0, 1, 2, ... n-1. The given n may be 0, in which case just return a length 0 array. You do not need a separate if-statement for the length-0 case; the for-loop should naturally execute 0 times in that case, so it just works. The syntax to make a new int array is: new int[desired_length] \u0026nbsp; (See also: \u003ca href\u003d\"/doc/practice/fizzbuzz-code.html\"\u003eFizzBuzz Code\u003c/a\u003e) ",
    "examples": "fizzArray(4) → {0, 1, 2, 3} fizzArray(1) → {0} fizzArray(10) → {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n",
    "template": "public int[] fizzArray(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "4"
          ],
          "expectedValue": "{0, 1, 2, 3}"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "{0}"
        },
        {
          "inData": [
            "10"
          ],
          "expectedValue": "{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}"
        },
        {
          "inData": [
            "0"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "2"
          ],
          "expectedValue": "{0, 1}"
        },
        {
          "inData": [
            "7"
          ],
          "expectedValue": "{0, 1, 2, 3, 4, 5, 6}"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "only14",
    "description": "Given an array of ints, return true if every element is a 1 or a 4. ",
    "examples": "only14({1, 4, 1, 4}) → true only14({1, 4, 2, 4}) → false only14({1, 1}) → true\n",
    "template": "public boolean only14(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 4, 1, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 4, 2, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{4, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 4, 1, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 1, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 3, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 1, 5}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{4, 1, 4, 1}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "fizzArray2",
    "description": "Given a number n, create and return a new string array of length n, containing the strings \"0\", \"1\" \"2\" .. through n-1. N may be 0, in which case just return a length 0 array. Note: String.valueOf(xxx) will make the String form of most types. The syntax to make a new string array is: new String[desired_length] \u0026nbsp;(See also: \u003ca href\u003d\"/doc/practice/fizzbuzz-code.html\"\u003eFizzBuzz Code\u003c/a\u003e) ",
    "examples": "fizzArray2(4) → {\"0\", \"1\", \"2\", \"3\"} fizzArray2(10) → {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"} fizzArray2(2) → {\"0\", \"1\"}\n",
    "template": "public String[] fizzArray2(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "String[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "4"
          ],
          "expectedValue": "{\"0\", \"1\", \"2\", \"3\"}"
        },
        {
          "inData": [
            "10"
          ],
          "expectedValue": "{\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"}"
        },
        {
          "inData": [
            "2"
          ],
          "expectedValue": "{\"0\", \"1\"}"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "{\"0\"}"
        },
        {
          "inData": [
            "0"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "7"
          ],
          "expectedValue": "{\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\"}"
        },
        {
          "inData": [
            "9"
          ],
          "expectedValue": "{\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"}"
        },
        {
          "inData": [
            "11"
          ],
          "expectedValue": "{\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"}"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "no14",
    "description": "Given an array of ints, return true if it contains no 1\u0027s or it contains no 4\u0027s. ",
    "examples": "no14({1, 2, 3}) → true no14({1, 2, 3, 4}) → false no14({2, 3, 4}) → true\n",
    "template": "public boolean no14(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 3, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 4, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 2, 4, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 3, 4, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 1, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 1, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{9, 4, 4, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{4, 2, 3, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{4, 2, 3, 5}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{4, 4, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 4, 4}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "isEverywhere",
    "description": "We\u0027ll say that a value is \"everywhere\" in an array if for every pair of adjacent elements in the array, at least one of the pair is that value. Return true if the given value is everywhere in the array. ",
    "examples": "isEverywhere({1, 2, 1, 3}, 1) → true isEverywhere({1, 2, 1, 3}, 2) → false isEverywhere({1, 2, 1, 3, 4}, 1) → false\n",
    "template": "public boolean isEverywhere(int[] nums, int val) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        },
        {
          "type": "int",
          "name": "val"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 1, 3}",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 1, 3}",
            "2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 1, 3, 4}",
            "1"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 1, 2, 1}",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 1, 2, 1}",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 1, 2, 3, 1}",
            "2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 1}",
            "3"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 1}",
            "2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3}",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{}",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 1, 2, 3, 2, 5}",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 1, 1, 1, 2}",
            "2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 1, 2, 1, 1, 2}",
            "2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 1, 2, 2, 2, 1, 1, 2}",
            "2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 1, 2, 2, 2, 1, 2, 1}",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 1, 2, 1, 2}",
            "2"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "either24",
    "description": "Given an array of ints, return true if the array contains a 2 next to a 2 or a 4 next to a 4, but not both. ",
    "examples": "either24({1, 2, 2}) → true either24({4, 4, 1}) → true either24({4, 4, 1, 2, 2}) → false\n",
    "template": "public boolean either24(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{4, 4, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{4, 4, 1, 2, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 5, 9}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 2, 3, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3, 2, 2, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3, 2, 2, 4, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{4, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "matchUp",
    "description": "Given arrays nums1 and nums2 of the same length, for every element in nums1, consider the corresponding element in nums2 (at the same index). Return the count of the number of times that the two elements differ by 2 or less, but are not equal. ",
    "examples": "matchUp({1, 2, 3}, {2, 3, 10}) → 2 matchUp({1, 2, 3}, {2, 3, 5}) → 3 matchUp({1, 2, 3}, {2, 3, 3}) → 2\n",
    "template": "public int matchUp(int[] nums1, int[] nums2) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums1"
        },
        {
          "type": "int[]",
          "name": "nums2"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}",
            "{2, 3, 10}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 2, 3}",
            "{2, 3, 5}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{1, 2, 3}",
            "{2, 3, 3}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{5, 3}",
            "{5, 5}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{5, 3}",
            "{4, 4}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{5, 3}",
            "{3, 3}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{5, 3}",
            "{2, 2}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{5, 3}",
            "{1, 1}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{5, 3}",
            "{0, 0}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{4}",
            "{4}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{4}",
            "{5}"
          ],
          "expectedValue": "1"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "has77",
    "description": "Given an array of ints, return true if the array contains two 7\u0027s next to each other, or there are two 7\u0027s separated by one element, such as with {7, 1, 7}. ",
    "examples": "has77({1, 7, 7}) → true has77({1, 7, 1, 7}) → true has77({1, 7, 1, 1, 7}) → false\n",
    "template": "public boolean has77(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 7, 7}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 7, 1, 7}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 7, 1, 1, 7}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{7, 7, 1, 1, 7}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 7, 2, 2, 7, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 7, 2, 2, 7, 7}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{7, 2, 7, 2, 2, 7}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{7, 2, 6, 2, 2, 7}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{7, 7, 7}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{7, 1, 7}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{7, 1, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 7}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{7}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "has12",
    "description": "Given an array of ints, return true if there is a 1 in the array with a 2 somewhere later in the array. ",
    "examples": "has12({1, 3, 2}) → true has12({3, 1, 2}) → true has12({3, 1, 4, 5, 2}) → true\n",
    "template": "public boolean has12(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 3, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 1, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 1, 4, 5, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 1, 4, 5, 6}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 1, 4, 1, 6, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 1, 4, 1, 6, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 1, 4, 1, 6}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 5, 9}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 5, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 2, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "modThree",
    "description": "Given an array of ints, return true if the array contains either 3 even or 3 odd values all next to each other. ",
    "examples": "modThree({2, 1, 3, 5}) → true modThree({2, 1, 2, 5}) → false modThree({2, 4, 2, 5}) → true\n",
    "template": "public boolean modThree(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{2, 1, 3, 5}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 1, 2, 5}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 4, 2, 5}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 1, 2, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{9, 9, 9}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{9, 7, 2, 9}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{9, 7, 2, 9, 2, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{9, 7, 2, 9, 2, 2, 6}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "haveThree",
    "description": "Given an array of ints, return true if the value 3 appears in the array exactly 3 times, and no 3\u0027s are next to each other. ",
    "examples": "haveThree({3, 1, 3, 1, 3}) → true haveThree({3, 1, 3, 3}) → false haveThree({3, 4, 3, 3, 4}) → false\n",
    "template": "public boolean haveThree(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{3, 1, 3, 1, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 1, 3, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 4, 3, 3, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 3, 1, 3, 1, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 3, 1, 3, 1, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 3, 3, 1, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 3, 1, 3, 1, 3, 4, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 4, 3, 4, 3, 4, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 3, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "twoTwo",
    "description": "Given an array of ints, return true if every 2 that appears in the array is next to another 2. ",
    "examples": "twoTwo({4, 2, 2, 3}) → true twoTwo({2, 2, 4}) → true twoTwo({2, 2, 4, 2}) → false\n",
    "template": "public boolean twoTwo(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{4, 2, 2, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 2, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 2, 4, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 3, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 2, 3, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 2, 7}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 2, 7, 2, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{4, 2, 2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{5, 2, 2, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 2, 5, 2}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "sameEnds",
    "description": "Return true if the group of N numbers at the start and end of the array are the same. For example, with {5, 6, 45, 99, 13, 5, 6}, the ends are the same for n\u003d0 and n\u003d2, and false for n\u003d1 and n\u003d3. You may assume that n is in the range 0..nums.length inclusive. ",
    "examples": "sameEnds({5, 6, 45, 99, 13, 5, 6}, 1) → false sameEnds({5, 6, 45, 99, 13, 5, 6}, 2) → true sameEnds({5, 6, 45, 99, 13, 5, 6}, 3) → false\n",
    "template": "public boolean sameEnds(int[] nums, int len) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        },
        {
          "type": "int",
          "name": "len"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{5, 6, 45, 99, 13, 5, 6}",
            "1"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{5, 6, 45, 99, 13, 5, 6}",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{5, 6, 45, 99, 13, 5, 6}",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 5, 2, 1}",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 5, 2, 1}",
            "2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 5, 2, 1}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 5, 2, 1}",
            "5"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 1}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 1}",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 1}",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 1}",
            "3"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1}",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{4, 2, 4, 5}",
            "1"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "tripleUp",
    "description": "Return true if the array contains, somewhere, three increasing adjacent numbers like .... 4, 5, 6, ... or 23, 24, 25. ",
    "examples": "tripleUp({1, 4, 5, 6, 2}) → true tripleUp({1, 2, 3}) → true tripleUp({1, 2, 4}) → false\n",
    "template": "public boolean tripleUp(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 4, 5, 6, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 4, 5, 7, 6, 5, 6, 7, 6}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 4, 5, 7, 6, 5, 7, 7, 6}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{10, 9, 8, -100, -99, -98, 100}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{10, 9, 8, -100, -99, 99, 100}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{-100, -99, -99, 100, 101, 102}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 3, 5, 6, 8, 9, 2, 3}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "fizzArray3",
    "description": "Given \u003cb\u003estart\u003c/b\u003e and \u003cb\u003eend\u003c/b\u003e numbers, return a new array containing the sequence of integers from start up to but not including end, so start\u003d5 and end\u003d10 yields {5, 6, 7, 8, 9}. The end number will be greater or equal to the start number. Note that a length-0 array is valid. (See also: \u003ca href\u003d\"/doc/practice/fizzbuzz-code.html\"\u003eFizzBuzz Code\u003c/a\u003e) ",
    "examples": "fizzArray3(5, 10) → {5, 6, 7, 8, 9} fizzArray3(11, 18) → {11, 12, 13, 14, 15, 16, 17} fizzArray3(1, 3) → {1, 2}\n",
    "template": "public int[] fizzArray3(int start, int end) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "start"
        },
        {
          "type": "int",
          "name": "end"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "5",
            "10"
          ],
          "expectedValue": "{5, 6, 7, 8, 9}"
        },
        {
          "inData": [
            "11",
            "18"
          ],
          "expectedValue": "{11, 12, 13, 14, 15, 16, 17}"
        },
        {
          "inData": [
            "1",
            "3"
          ],
          "expectedValue": "{1, 2}"
        },
        {
          "inData": [
            "1",
            "2"
          ],
          "expectedValue": "{1}"
        },
        {
          "inData": [
            "1",
            "1"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "1000",
            "1005"
          ],
          "expectedValue": "{1000, 1001, 1002, 1003, 1004}"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "shiftLeft",
    "description": "Return an array that is \"left shifted\" by one -- so {6, 2, 5, 3} returns {2, 5, 3, 6}. You may modify and return the given array, or return a new array. ",
    "examples": "shiftLeft({6, 2, 5, 3}) → {2, 5, 3, 6} shiftLeft({1, 2}) → {2, 1} shiftLeft({1}) → {1}\n",
    "template": "public int[] shiftLeft(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{6, 2, 5, 3}"
          ],
          "expectedValue": "{2, 5, 3, 6}"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "{2, 1}"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "{1}"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "{1, 1, 2, 2, 4}"
          ],
          "expectedValue": "{1, 2, 2, 4, 1}"
        },
        {
          "inData": [
            "{1, 1, 1}"
          ],
          "expectedValue": "{1, 1, 1}"
        },
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "{2, 3, 1}"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "tenRun",
    "description": "For each multiple of 10 in the given array, change all the values following it to be that multiple of 10, until encountering another multiple of 10. So {2, 10, 3, 4, 20, 5} yields {2, 10, 10, 10, 20, 20}. ",
    "examples": "tenRun({2, 10, 3, 4, 20, 5}) → {2, 10, 10, 10, 20, 20} tenRun({10, 1, 20, 2}) → {10, 10, 20, 20} tenRun({10, 1, 9, 20}) → {10, 10, 10, 20}\n",
    "template": "public int[] tenRun(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{2, 10, 3, 4, 20, 5}"
          ],
          "expectedValue": "{2, 10, 10, 10, 20, 20}"
        },
        {
          "inData": [
            "{10, 1, 20, 2}"
          ],
          "expectedValue": "{10, 10, 20, 20}"
        },
        {
          "inData": [
            "{10, 1, 9, 20}"
          ],
          "expectedValue": "{10, 10, 10, 20}"
        },
        {
          "inData": [
            "{1, 2, 50, 1}"
          ],
          "expectedValue": "{1, 2, 50, 50}"
        },
        {
          "inData": [
            "{1, 20, 50, 1}"
          ],
          "expectedValue": "{1, 20, 50, 50}"
        },
        {
          "inData": [
            "{10, 10}"
          ],
          "expectedValue": "{10, 10}"
        },
        {
          "inData": [
            "{10, 2}"
          ],
          "expectedValue": "{10, 10}"
        },
        {
          "inData": [
            "{0, 2}"
          ],
          "expectedValue": "{0, 0}"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "{1, 2}"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "{1}"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "{}"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "pre4",
    "description": "Given a non-empty array of ints, return a new array containing the elements from the original array that come before the first 4 in the original array. The original array will contain at least one 4. Note that it is valid in java to create an array of length 0. ",
    "examples": "pre4({1, 2, 4, 1}) → {1, 2} pre4({3, 1, 4}) → {3, 1} pre4({1, 4, 4}) → {1}\n",
    "template": "public int[] pre4(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 4, 1}"
          ],
          "expectedValue": "{1, 2}"
        },
        {
          "inData": [
            "{3, 1, 4}"
          ],
          "expectedValue": "{3, 1}"
        },
        {
          "inData": [
            "{1, 4, 4}"
          ],
          "expectedValue": "{1}"
        },
        {
          "inData": [
            "{1, 4, 4, 2}"
          ],
          "expectedValue": "{1}"
        },
        {
          "inData": [
            "{1, 3, 4, 2, 4}"
          ],
          "expectedValue": "{1, 3}"
        },
        {
          "inData": [
            "{4, 4}"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "{3, 3, 4}"
          ],
          "expectedValue": "{3, 3}"
        },
        {
          "inData": [
            "{1, 2, 1, 4}"
          ],
          "expectedValue": "{1, 2, 1}"
        },
        {
          "inData": [
            "{2, 1, 4, 2}"
          ],
          "expectedValue": "{2, 1}"
        },
        {
          "inData": [
            "{2, 1, 2, 1, 4, 2}"
          ],
          "expectedValue": "{2, 1, 2, 1}"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "post4",
    "description": "Given a non-empty array of ints, return a new array containing the elements from the original array that come after the last 4 in the original array. The original array will contain at least one 4. Note that it is valid in java to create an array of length 0. ",
    "examples": "post4({2, 4, 1, 2}) → {1, 2} post4({4, 1, 4, 2}) → {2} post4({4, 4, 1, 2, 3}) → {1, 2, 3}\n",
    "template": "public int[] post4(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{2, 4, 1, 2}"
          ],
          "expectedValue": "{1, 2}"
        },
        {
          "inData": [
            "{4, 1, 4, 2}"
          ],
          "expectedValue": "{2}"
        },
        {
          "inData": [
            "{4, 4, 1, 2, 3}"
          ],
          "expectedValue": "{1, 2, 3}"
        },
        {
          "inData": [
            "{4, 2}"
          ],
          "expectedValue": "{2}"
        },
        {
          "inData": [
            "{4, 4, 3}"
          ],
          "expectedValue": "{3}"
        },
        {
          "inData": [
            "{4, 4}"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "{4}"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "{2, 4, 1, 4, 3, 2}"
          ],
          "expectedValue": "{3, 2}"
        },
        {
          "inData": [
            "{4, 1, 4, 2, 2, 2}"
          ],
          "expectedValue": "{2, 2, 2}"
        },
        {
          "inData": [
            "{3, 4, 3, 2}"
          ],
          "expectedValue": "{3, 2}"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "notAlone",
    "description": "We\u0027ll say that an element in an array is \"alone\" if there are values before and after it, and those values are different from it. Return a version of the given array where every instance of the given value which is alone is replaced by whichever value to its left or right is larger. ",
    "examples": "notAlone({1, 2, 3}, 2) → {1, 3, 3} notAlone({1, 2, 3, 2, 5, 2}, 2) → {1, 3, 3, 5, 5, 2} notAlone({3, 4}, 3) → {3, 4}\n",
    "template": "public int[] notAlone(int[] nums, int val) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        },
        {
          "type": "int",
          "name": "val"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3}",
            "2"
          ],
          "expectedValue": "{1, 3, 3}"
        },
        {
          "inData": [
            "{1, 2, 3, 2, 5, 2}",
            "2"
          ],
          "expectedValue": "{1, 3, 3, 5, 5, 2}"
        },
        {
          "inData": [
            "{3, 4}",
            "3"
          ],
          "expectedValue": "{3, 4}"
        },
        {
          "inData": [
            "{3, 3}",
            "3"
          ],
          "expectedValue": "{3, 3}"
        },
        {
          "inData": [
            "{1, 3, 1, 2}",
            "1"
          ],
          "expectedValue": "{1, 3, 3, 2}"
        },
        {
          "inData": [
            "{3}",
            "3"
          ],
          "expectedValue": "{3}"
        },
        {
          "inData": [
            "{}",
            "3"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "{7, 1, 6}",
            "1"
          ],
          "expectedValue": "{7, 7, 6}"
        },
        {
          "inData": [
            "{1, 1, 1}",
            "1"
          ],
          "expectedValue": "{1, 1, 1}"
        },
        {
          "inData": [
            "{1, 1, 1, 2}",
            "1"
          ],
          "expectedValue": "{1, 1, 1, 2}"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "zeroFront",
    "description": "Return an array that contains the exact same numbers as the given array, but rearranged so that all the zeros are grouped at the start of the array. The order of the non-zero numbers does not matter. So {1, 0, 0, 1} becomes {0 ,0, 1, 1}. You may modify and return the given array or make a new array. ",
    "examples": "zeroFront({1, 0, 0, 1}) → {0, 0, 1, 1} zeroFront({0, 1, 1, 0, 1}) → {0, 0, 1, 1, 1} zeroFront({1, 0}) → {0, 1}\n",
    "template": "public int[] zeroFront(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 0, 0, 1}"
          ],
          "expectedValue": "{0, 0, 1, 1}"
        },
        {
          "inData": [
            "{0, 1, 1, 0, 1}"
          ],
          "expectedValue": "{0, 0, 1, 1, 1}"
        },
        {
          "inData": [
            "{1, 0}"
          ],
          "expectedValue": "{0, 1}"
        },
        {
          "inData": [
            "{0, 1}"
          ],
          "expectedValue": "{0, 1}"
        },
        {
          "inData": [
            "{1, 1, 1, 0}"
          ],
          "expectedValue": "{0, 1, 1, 1}"
        },
        {
          "inData": [
            "{2, 2, 2, 2}"
          ],
          "expectedValue": "{2, 2, 2, 2}"
        },
        {
          "inData": [
            "{0, 0, 1, 0}"
          ],
          "expectedValue": "{0, 0, 0, 1}"
        },
        {
          "inData": [
            "{-1, 0, 0, -1, 0}"
          ],
          "expectedValue": "{0, 0, 0, -1, -1}"
        },
        {
          "inData": [
            "{0, -3, 0, -3}"
          ],
          "expectedValue": "{0, 0, -3, -3}"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "{9, 9, 0, 9, 0, 9}"
          ],
          "expectedValue": "{0, 0, 9, 9, 9, 9}"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "withoutTen",
    "description": "Return a version of the given array where all the 10\u0027s have been removed. The remaining elements should shift left towards the start of the array as needed, and the empty spaces a the end of the array should be 0. So {1, 10, 10, 2} yields {1, 2, 0, 0}. You may modify and return the given array or make a new array. ",
    "examples": "withoutTen({1, 10, 10, 2}) → {1, 2, 0, 0} withoutTen({10, 2, 10}) → {2, 0, 0} withoutTen({1, 99, 10}) → {1, 99, 0}\n",
    "template": "public int[] withoutTen(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 10, 10, 2}"
          ],
          "expectedValue": "{1, 2, 0, 0}"
        },
        {
          "inData": [
            "{10, 2, 10}"
          ],
          "expectedValue": "{2, 0, 0}"
        },
        {
          "inData": [
            "{1, 99, 10}"
          ],
          "expectedValue": "{1, 99, 0}"
        },
        {
          "inData": [
            "{10, 13, 10, 14}"
          ],
          "expectedValue": "{13, 14, 0, 0}"
        },
        {
          "inData": [
            "{10, 13, 10, 14, 10}"
          ],
          "expectedValue": "{13, 14, 0, 0, 0}"
        },
        {
          "inData": [
            "{10, 10, 3}"
          ],
          "expectedValue": "{3, 0, 0}"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "{1}"
        },
        {
          "inData": [
            "{13, 1}"
          ],
          "expectedValue": "{13, 1}"
        },
        {
          "inData": [
            "{10}"
          ],
          "expectedValue": "{0}"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "{}"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "zeroMax",
    "description": "Return a version of the given array where each zero value in the array is replaced by the largest odd value to the right of the zero in the array. If there is no odd value to the right of the zero, leave the zero as a zero. ",
    "examples": "zeroMax({0, 5, 0, 3}) → {5, 5, 3, 3} zeroMax({0, 4, 0, 3}) → {3, 4, 3, 3} zeroMax({0, 1, 0}) → {1, 1, 0}\n",
    "template": "public int[] zeroMax(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{0, 5, 0, 3}"
          ],
          "expectedValue": "{5, 5, 3, 3}"
        },
        {
          "inData": [
            "{0, 4, 0, 3}"
          ],
          "expectedValue": "{3, 4, 3, 3}"
        },
        {
          "inData": [
            "{0, 1, 0}"
          ],
          "expectedValue": "{1, 1, 0}"
        },
        {
          "inData": [
            "{0, 1, 5}"
          ],
          "expectedValue": "{5, 1, 5}"
        },
        {
          "inData": [
            "{0, 2, 0}"
          ],
          "expectedValue": "{0, 2, 0}"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "{1}"
        },
        {
          "inData": [
            "{0}"
          ],
          "expectedValue": "{0}"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "{7, 0, 4, 3, 0, 2}"
          ],
          "expectedValue": "{7, 3, 4, 3, 0, 2}"
        },
        {
          "inData": [
            "{7, 0, 4, 3, 0, 1}"
          ],
          "expectedValue": "{7, 3, 4, 3, 1, 1}"
        },
        {
          "inData": [
            "{7, 0, 4, 3, 0, 0}"
          ],
          "expectedValue": "{7, 3, 4, 3, 0, 0}"
        },
        {
          "inData": [
            "{7, 0, 1, 0, 0, 7}"
          ],
          "expectedValue": "{7, 7, 1, 7, 7, 7}"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "evenOdd",
    "description": "Return an array that contains the exact same numbers as the given array, but rearranged so that all the even numbers come before all the odd numbers. Other than that, the numbers can be in any order. You may modify and return the given array, or make a new array. ",
    "examples": "evenOdd({1, 0, 1, 0, 0, 1, 1}) → {0, 0, 0, 1, 1, 1, 1} evenOdd({3, 3, 2}) → {2, 3, 3} evenOdd({2, 2, 2}) → {2, 2, 2}\n",
    "template": "public int[] evenOdd(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 0, 1, 0, 0, 1, 1}"
          ],
          "expectedValue": "{0, 0, 0, 1, 1, 1, 1}"
        },
        {
          "inData": [
            "{3, 3, 2}"
          ],
          "expectedValue": "{2, 3, 3}"
        },
        {
          "inData": [
            "{2, 2, 2}"
          ],
          "expectedValue": "{2, 2, 2}"
        },
        {
          "inData": [
            "{3, 2, 2}"
          ],
          "expectedValue": "{2, 2, 3}"
        },
        {
          "inData": [
            "{1, 1, 0, 1, 0}"
          ],
          "expectedValue": "{0, 0, 1, 1, 1}"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "{1}"
        },
        {
          "inData": [
            "{1, 2}"
          ],
          "expectedValue": "{2, 1}"
        },
        {
          "inData": [
            "{2, 1}"
          ],
          "expectedValue": "{2, 1}"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "{}"
        }
      ]
    }
  },
  {
    "groupName": "Array-2",
    "title": "fizzBuzz",
    "description": "This is slightly more difficult version of the famous FizzBuzz problem which is sometimes given as a first problem for job interviews. (See also: \u003ca href\u003d\"/doc/practice/fizzbuzz-code.html\"\u003eFizzBuzz Code\u003c/a\u003e.) Consider the series of numbers beginning at \u003cb\u003estart\u003c/b\u003e and running up to but not including \u003cb\u003eend\u003c/b\u003e, so for example start\u003d1 and end\u003d5 gives the series 1, 2, 3, 4. Return a new String[] array containing the string form of these numbers, except for multiples of 3, use \"Fizz\" instead of the number, for multiples of 5 use \"Buzz\", and for multiples of both 3 and 5 use \"FizzBuzz\". In Java, String.valueOf(xxx) will make the String form of an int or other type. This version is a little more complicated than the usual version since you have to allocate and index into an array instead of just printing, and we vary the start/end instead of just always doing 1..100. ",
    "examples": "fizzBuzz(1, 6) → {\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"} fizzBuzz(1, 8) → {\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\"} fizzBuzz(1, 11) → {\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\"}\n",
    "template": "public String[] fizzBuzz(int start, int end) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "start"
        },
        {
          "type": "int",
          "name": "end"
        }
      ],
      "returnType": "String[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1",
            "6"
          ],
          "expectedValue": "{\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"}"
        },
        {
          "inData": [
            "1",
            "8"
          ],
          "expectedValue": "{\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\"}"
        },
        {
          "inData": [
            "1",
            "11"
          ],
          "expectedValue": "{\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\"}"
        },
        {
          "inData": [
            "1",
            "16"
          ],
          "expectedValue": "{\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"}"
        },
        {
          "inData": [
            "1",
            "4"
          ],
          "expectedValue": "{\"1\", \"2\", \"Fizz\"}"
        },
        {
          "inData": [
            "1",
            "2"
          ],
          "expectedValue": "{\"1\"}"
        },
        {
          "inData": [
            "50",
            "56"
          ],
          "expectedValue": "{\"Buzz\", \"Fizz\", \"52\", \"53\", \"Fizz\", \"Buzz\"}"
        },
        {
          "inData": [
            "15",
            "17"
          ],
          "expectedValue": "{\"FizzBuzz\", \"16\"}"
        },
        {
          "inData": [
            "30",
            "36"
          ],
          "expectedValue": "{\"FizzBuzz\", \"31\", \"32\", \"Fizz\", \"34\", \"Buzz\"}"
        },
        {
          "inData": [
            "1000",
            "1006"
          ],
          "expectedValue": "{\"Buzz\", \"1001\", \"Fizz\", \"1003\", \"1004\", \"FizzBuzz\"}"
        },
        {
          "inData": [
            "99",
            "102"
          ],
          "expectedValue": "{\"Fizz\", \"Buzz\", \"101\"}"
        },
        {
          "inData": [
            "14",
            "20"
          ],
          "expectedValue": "{\"14\", \"FizzBuzz\", \"16\", \"17\", \"Fizz\", \"19\"}"
        }
      ]
    }
  },
  {
    "groupName": "Array-3",
    "title": "maxSpan",
    "description": "Consider the leftmost and righmost appearances of some value in an array. We\u0027ll say that the \"span\" is the number of elements between the two inclusive. A single value has a span of 1. Returns the largest span found in the given array. (Efficiency is not a priority.) ",
    "examples": "maxSpan({1, 2, 1, 1, 3}) → 4 maxSpan({1, 4, 2, 1, 4, 1, 4}) → 6 maxSpan({1, 4, 2, 1, 4, 4, 4}) → 6\n",
    "template": "public int maxSpan(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 1, 1, 3}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{1, 4, 2, 1, 4, 1, 4}"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "{1, 4, 2, 1, 4, 4, 4}"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "{3, 3, 3}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{3, 9, 3}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{3, 9, 9}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{3, 9}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{3, 3}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "1"
        }
      ]
    }
  },
  {
    "groupName": "Array-3",
    "title": "fix34",
    "description": "Return an array that contains exactly the same numbers as the given array, but rearranged so that every 3 is immediately followed by a 4. Do not move the 3\u0027s, but every other number may move. The array contains the same number of 3\u0027s and 4\u0027s, every 3 has a number after it that is not a 3 or 4, and a 3 appears in the array before any 4. ",
    "examples": "fix34({1, 3, 1, 4}) → {1, 3, 4, 1} fix34({1, 3, 1, 4, 4, 3, 1}) → {1, 3, 4, 1, 1, 3, 4} fix34({3, 2, 2, 4}) → {3, 4, 2, 2}\n",
    "template": "public int[] fix34(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 3, 1, 4}"
          ],
          "expectedValue": "{1, 3, 4, 1}"
        },
        {
          "inData": [
            "{1, 3, 1, 4, 4, 3, 1}"
          ],
          "expectedValue": "{1, 3, 4, 1, 1, 3, 4}"
        },
        {
          "inData": [
            "{3, 2, 2, 4}"
          ],
          "expectedValue": "{3, 4, 2, 2}"
        },
        {
          "inData": [
            "{3, 2, 3, 2, 4, 4}"
          ],
          "expectedValue": "{3, 4, 3, 4, 2, 2}"
        },
        {
          "inData": [
            "{2, 3, 2, 3, 2, 4, 4}"
          ],
          "expectedValue": "{2, 3, 4, 3, 4, 2, 2}"
        },
        {
          "inData": [
            "{3, 1, 4}"
          ],
          "expectedValue": "{3, 4, 1}"
        },
        {
          "inData": [
            "{3, 4, 1}"
          ],
          "expectedValue": "{3, 4, 1}"
        },
        {
          "inData": [
            "{1, 1, 1}"
          ],
          "expectedValue": "{1, 1, 1}"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "{1}"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "{7, 3, 7, 7, 4}"
          ],
          "expectedValue": "{7, 3, 4, 7, 7}"
        },
        {
          "inData": [
            "{3, 1, 4, 3, 1, 4}"
          ],
          "expectedValue": "{3, 4, 1, 3, 4, 1}"
        },
        {
          "inData": [
            "{3, 1, 1, 3, 4, 4}"
          ],
          "expectedValue": "{3, 4, 1, 3, 4, 1}"
        }
      ]
    }
  },
  {
    "groupName": "Array-3",
    "title": "fix45",
    "description": "(This is a slightly harder version of the fix34 problem.) Return an array that contains exactly the same numbers as the given array, but rearranged so that every 4 is immediately followed by a 5. Do not move the 4\u0027s, but every other number may move. The array contains the same number of 4\u0027s and 5\u0027s, and every 4 has a number after it that is not a 4. In this version, 5\u0027s may appear anywhere in the original array. ",
    "examples": "fix45({5, 4, 9, 4, 9, 5}) → {9, 4, 5, 4, 5, 9} fix45({1, 4, 1, 5}) → {1, 4, 5, 1} fix45({1, 4, 1, 5, 5, 4, 1}) → {1, 4, 5, 1, 1, 4, 5}\n",
    "template": "public int[] fix45(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{5, 4, 9, 4, 9, 5}"
          ],
          "expectedValue": "{9, 4, 5, 4, 5, 9}"
        },
        {
          "inData": [
            "{1, 4, 1, 5}"
          ],
          "expectedValue": "{1, 4, 5, 1}"
        },
        {
          "inData": [
            "{1, 4, 1, 5, 5, 4, 1}"
          ],
          "expectedValue": "{1, 4, 5, 1, 1, 4, 5}"
        },
        {
          "inData": [
            "{4, 9, 4, 9, 5, 5, 4, 9, 5}"
          ],
          "expectedValue": "{4, 5, 4, 5, 9, 9, 4, 5, 9}"
        },
        {
          "inData": [
            "{5, 5, 4, 1, 4, 1}"
          ],
          "expectedValue": "{1, 1, 4, 5, 4, 5}"
        },
        {
          "inData": [
            "{4, 2, 2, 5}"
          ],
          "expectedValue": "{4, 5, 2, 2}"
        },
        {
          "inData": [
            "{4, 2, 4, 2, 5, 5}"
          ],
          "expectedValue": "{4, 5, 4, 5, 2, 2}"
        },
        {
          "inData": [
            "{4, 2, 4, 5, 5}"
          ],
          "expectedValue": "{4, 5, 4, 5, 2}"
        },
        {
          "inData": [
            "{1, 1, 1}"
          ],
          "expectedValue": "{1, 1, 1}"
        },
        {
          "inData": [
            "{4, 5}"
          ],
          "expectedValue": "{4, 5}"
        },
        {
          "inData": [
            "{5, 4, 1}"
          ],
          "expectedValue": "{1, 4, 5}"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "{5, 4, 5, 4, 1}"
          ],
          "expectedValue": "{1, 4, 5, 4, 5}"
        },
        {
          "inData": [
            "{4, 5, 4, 1, 5}"
          ],
          "expectedValue": "{4, 5, 4, 5, 1}"
        },
        {
          "inData": [
            "{3, 4, 5}"
          ],
          "expectedValue": "{3, 4, 5}"
        },
        {
          "inData": [
            "{4, 1, 5}"
          ],
          "expectedValue": "{4, 5, 1}"
        },
        {
          "inData": [
            "{5, 4, 1}"
          ],
          "expectedValue": "{1, 4, 5}"
        },
        {
          "inData": [
            "{2, 4, 2, 5}"
          ],
          "expectedValue": "{2, 4, 5, 2}"
        }
      ]
    }
  },
  {
    "groupName": "Array-3",
    "title": "canBalance",
    "description": "Given a non-empty array, return true if there is a place to split the array so that the sum of the numbers on one side is equal to the sum of the numbers on the other side. ",
    "examples": "canBalance({1, 1, 1, 2, 1}) → true canBalance({2, 1, 1, 2, 1}) → false canBalance({10, 10}) → true\n",
    "template": "public boolean canBalance(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 1, 1, 2, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 1, 1, 2, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{10, 10}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{10, 0, 1, -1, 10}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 1, 1, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 1, 1, 1, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 3, 4, 1, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3, 1, 0, 2, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3, 1, 0, 1, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1, 1, 2, 1}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Array-3",
    "title": "linearIn",
    "description": "Given two arrays of ints sorted in increasing order, \u003cb\u003eouter\u003c/b\u003e and \u003cb\u003einner\u003c/b\u003e, return true if all of the numbers in inner appear in outer. The best solution makes only a single \"linear\" pass of both arrays, taking advantage of the fact that both arrays are already in sorted order. ",
    "examples": "linearIn({1, 2, 4, 6}, {2, 4}) → true linearIn({1, 2, 4, 6}, {2, 3, 4}) → false linearIn({1, 2, 4, 4, 6}, {2, 4}) → true\n",
    "template": "public boolean linearIn(int[] outer, int[] inner) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "outer"
        },
        {
          "type": "int[]",
          "name": "inner"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 4, 6}",
            "{2, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 4, 6}",
            "{2, 3, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 4, 4, 6}",
            "{2, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 2, 4, 4, 6, 6}",
            "{2, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 2, 2, 2, 2}",
            "{2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 2, 2, 2, 2}",
            "{2, 4}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 2, 2, 2, 4}",
            "{2, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3}",
            "{2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3}",
            "{-1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3}",
            "{}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{-1, 0, 3, 3, 3, 10, 12}",
            "{-1, 0, 3, 12}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{-1, 0, 3, 3, 3, 10, 12}",
            "{0, 3, 12, 14}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{-1, 0, 3, 3, 3, 10, 12}",
            "{-1, 10, 11}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Array-3",
    "title": "squareUp",
    "description": "Given n\u0026gt;\u003d0, create an array length n*n with the following pattern, shown here for n\u003d3 : {0, 0, 1, \u0026nbsp;\u0026nbsp; 0, 2, 1, \u0026nbsp;\u0026nbsp; 3, 2, 1} (spaces added to show the 3 groups). ",
    "examples": "squareUp(3) → {0, 0, 1, 0, 2, 1, 3, 2, 1} squareUp(2) → {0, 1, 2, 1} squareUp(4) → {0, 0, 0, 1, 0, 0, 2, 1, 0, 3, 2, 1, 4, 3, 2, 1}\n",
    "template": "public int[] squareUp(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "3"
          ],
          "expectedValue": "{0, 0, 1, 0, 2, 1, 3, 2, 1}"
        },
        {
          "inData": [
            "2"
          ],
          "expectedValue": "{0, 1, 2, 1}"
        },
        {
          "inData": [
            "4"
          ],
          "expectedValue": "{0, 0, 0, 1, 0, 0, 2, 1, 0, 3, 2, 1, 4, 3, 2, 1}"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "{1}"
        },
        {
          "inData": [
            "0"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "6"
          ],
          "expectedValue": "{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 1, 0, 0, 0, 3, 2, 1, 0, 0, 4, 3, 2, 1, 0, 5, 4, 3, 2, 1, 6, 5, 4, 3, 2, 1}"
        }
      ]
    }
  },
  {
    "groupName": "Array-3",
    "title": "seriesUp",
    "description": "Given n\u0026gt;\u003d0, create an array with the pattern {1, \u0026nbsp;\u0026nbsp; 1, 2, \u0026nbsp;\u0026nbsp; 1, 2, 3, \u0026nbsp;\u0026nbsp;... 1, 2, 3 .. n} (spaces added to show the grouping). Note that the length of the array will be 1 + 2 + 3 ... + n, which is known to sum to exactly n*(n + 1)/2. ",
    "examples": "seriesUp(3) → {1, 1, 2, 1, 2, 3} seriesUp(4) → {1, 1, 2, 1, 2, 3, 1, 2, 3, 4} seriesUp(2) → {1, 1, 2}\n",
    "template": "public int[] seriesUp(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "3"
          ],
          "expectedValue": "{1, 1, 2, 1, 2, 3}"
        },
        {
          "inData": [
            "4"
          ],
          "expectedValue": "{1, 1, 2, 1, 2, 3, 1, 2, 3, 4}"
        },
        {
          "inData": [
            "2"
          ],
          "expectedValue": "{1, 1, 2}"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "{1}"
        },
        {
          "inData": [
            "0"
          ],
          "expectedValue": "{}"
        },
        {
          "inData": [
            "6"
          ],
          "expectedValue": "{1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6}"
        }
      ]
    }
  },
  {
    "groupName": "Array-3",
    "title": "maxMirror",
    "description": "We\u0027ll say that a \"mirror\" section in an array is a group of contiguous elements such that somewhere in the array, the same group appears in reverse order. For example, the largest mirror section in {1, 2, 3, 8, 9, 3, 2, 1} is length 3 (the {1, 2, 3} part). Return the size of the largest mirror section found in the given array. ",
    "examples": "maxMirror({1, 2, 3, 8, 9, 3, 2, 1}) → 3 maxMirror({1, 2, 1, 4}) → 3 maxMirror({7, 1, 2, 9, 7, 2, 1}) → 2\n",
    "template": "public int maxMirror(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 3, 8, 9, 3, 2, 1}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{1, 2, 1, 4}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{7, 1, 2, 9, 7, 2, 1}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{21, 22, 9, 8, 7, 6, 23, 24, 6, 7, 8, 9, 25, 7, 8, 9 }"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{1, 2, 1, 20, 21, 1, 2, 1, 2, 23, 24, 2, 1, 2, 1, 25}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{1, 2, 3, 2, 1}"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "{1, 2, 3, 3, 8}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 2, 7, 8, 1, 7, 2}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 1, 1}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{9, 1, 1, 4, 2, 1, 1, 1}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{5, 9, 9, 4, 5, 4, 9, 9, 2}"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "{5, 9, 9, 6, 5, 4, 9, 9, 2}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{5, 9, 1, 6, 5, 4, 1, 9, 5}"
          ],
          "expectedValue": "3"
        }
      ]
    }
  },
  {
    "groupName": "Array-3",
    "title": "countClumps",
    "description": "Say that a \"clump\" in an array is a series of 2 or more adjacent elements of the same value. Return the number of clumps in the given array. ",
    "examples": "countClumps({1, 2, 2, 3, 4, 4}) → 2 countClumps({1, 1, 2, 1, 1}) → 2 countClumps({1, 1, 1, 1, 1}) → 1\n",
    "template": "public int countClumps(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 2, 3, 4, 4}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 1, 2, 1, 1}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 1, 1, 1, 1}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{1, 2, 3}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{2, 2, 1, 1, 1, 2, 1, 1, 2, 2}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{0, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{0, 0, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2}"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "{0, 0, 0, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2}"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "0"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "scoresIncreasing",
    "description": "Given an array of scores, return true if each score is equal or greater than the one before. The array will be length 2 or more. ",
    "examples": "scoresIncreasing({1, 3, 4}) → true scoresIncreasing({1, 3, 2}) → false scoresIncreasing({1, 1, 4}) → true\n",
    "template": "public boolean scoresIncreasing(int[] scores) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "scores"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 3, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 3, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1, 4}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 2, 4, 4, 7}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 2, 4, 3, 7}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{-5, 4, 11}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "scores100",
    "description": "Given an array of scores, return true if there are scores of 100 next to each other in the array. The array length will be at least 2. ",
    "examples": "scores100({1, 100, 100}) → true scores100({1, 100, 99, 100}) → false scores100({100, 1, 100, 100}) → true\n",
    "template": "public boolean scores100(int[] scores) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "scores"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 100, 100}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 100, 99, 100}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{100, 1, 100, 100}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{100, 1, 100, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 100, 4, 5}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "scoresClump",
    "description": "Given an array of scores sorted in increasing order, return true if the array contains 3 adjacent scores that differ from each other by at most 2, such as with {3, 4, 5} or {3, 5, 5}. ",
    "examples": "scoresClump({3, 4, 5}) → true scoresClump({3, 4, 6}) → false scoresClump({1, 3, 5, 5}) → true\n",
    "template": "public boolean scoresClump(int[] scores) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "scores"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{3, 4, 5}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 4, 6}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 3, 5, 5}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 4, 5, 6}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 4, 5, 7}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 4, 4, 7}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 3, 6, 7, 9}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 3, 7, 7, 9}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{4, 5, 8}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "scoresAverage",
    "description": "Given an array of scores, compute the int average of the first half and the second half, and return whichever is larger. We\u0027ll say that the second half begins at index length/2. The array length will be at least 2. To practice decomposition, write a separate helper method \u0026lt;br\u0026gt;\u003ccode\u003eint average(int[] scores, int start, int end) { \u003c/code\u003e which computes the average of the elements between indexes start..end. Call your helper method twice to implement scoresAverage(). Write your helper method after your scoresAverage() method in the JavaBat text area. Normally you would compute averages with doubles, but here we use ints so the expected results are exact. ",
    "examples": "scoresAverage(). Write your helper method after your scoresAverage() method in the JavaBat text area. Normally you would compute averages with doubles, but here we use ints so the expected results are exact. scoresAverage({2, 2, 4, 4}) → 4 scoresAverage({4, 4, 4, 2, 2, 2}) → 4 scoresAverage({3, 4, 5, 1, 2, 3}) → 4\n",
    "template": "public int scoresAverage(int[] scores) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "scores"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{2, 2, 4, 4}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{4, 4, 4, 2, 2, 2}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{3, 4, 5, 1, 2, 3}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{5, 6}"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "{5, 4}"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "{5, 4, 5, 6, 2, 1, 2, 3}"
          ],
          "expectedValue": "5"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "wordsCount",
    "description": "Given an array of strings, return the count of the number of strings with the given length. ",
    "examples": "wordsCount({\"a\", \"bb\", \"b\", \"ccc\"}, 1) → 2 wordsCount({\"a\", \"bb\", \"b\", \"ccc\"}, 3) → 1 wordsCount({\"a\", \"bb\", \"b\", \"ccc\"}, 4) → 0\n",
    "template": "public int wordsCount(String[] words, int len) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String[]",
          "name": "words"
        },
        {
          "type": "int",
          "name": "len"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{\"a\", \"bb\", \"b\", \"ccc\"}",
            "1"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{\"a\", \"bb\", \"b\", \"ccc\"}",
            "3"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{\"a\", \"bb\", \"b\", \"ccc\"}",
            "4"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{\"xx\", \"yyy\", \"x\", \"yy\", \"z\"}",
            "1"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{\"xx\", \"yyy\", \"x\", \"yy\", \"z\"}",
            "2"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{\"xx\", \"yyy\", \"x\", \"yy\", \"z\"}",
            "3"
          ],
          "expectedValue": "1"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "wordsFront",
    "description": "Given an array of strings, return a new array containing the first N strings. N will be in the range 1..length. ",
    "examples": "wordsFront({\"a\", \"b\", \"c\", \"d\"}, 1) → {\"a\"} wordsFront({\"a\", \"b\", \"c\", \"d\"}, 2) → {\"a\", \"b\"} wordsFront({\"a\", \"b\", \"c\", \"d\"}, 3) → {\"a\", \"b\", \"c\"}\n",
    "template": "public String[] wordsFront(String[] words, int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String[]",
          "name": "words"
        },
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "String[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{\"a\", \"b\", \"c\", \"d\"}",
            "1"
          ],
          "expectedValue": "{\"a\"}"
        },
        {
          "inData": [
            "{\"a\", \"b\", \"c\", \"d\"}",
            "2"
          ],
          "expectedValue": "{\"a\", \"b\"}"
        },
        {
          "inData": [
            "{\"a\", \"b\", \"c\", \"d\"}",
            "3"
          ],
          "expectedValue": "{\"a\", \"b\", \"c\"}"
        },
        {
          "inData": [
            "{\"a\", \"b\", \"c\", \"d\"}",
            "4"
          ],
          "expectedValue": "{\"a\", \"b\", \"c\", \"d\"}"
        },
        {
          "inData": [
            "{\"Hi\", \"There\"}",
            "1"
          ],
          "expectedValue": "{\"Hi\"}"
        },
        {
          "inData": [
            "{\"Hi\", \"There\"}",
            "2"
          ],
          "expectedValue": "{\"Hi\", \"There\"}"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "wordsWithoutList",
    "description": "Given an array of strings, return a new List (e.g. an ArrayList) where all the strings of the given length are omitted. See wordsWithout() below which is more difficult because it uses arrays. ",
    "examples": "wordsWithoutList({\"a\", \"bb\", \"b\", \"ccc\"}, 1) → {\"bb\", \"ccc\"} wordsWithoutList({\"a\", \"bb\", \"b\", \"ccc\"}, 3) → {\"a\", \"bb\", \"b\"} wordsWithoutList({\"a\", \"bb\", \"b\", \"ccc\"}, 4) → {\"a\", \"bb\", \"b\", \"ccc\"}\n",
    "template": "public List wordsWithoutList(String[] words, int len) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String[]",
          "name": "words"
        },
        {
          "type": "int",
          "name": "len"
        }
      ],
      "returnType": "List"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{\"a\", \"bb\", \"b\", \"ccc\"}",
            "1"
          ],
          "expectedValue": "{\"bb\", \"ccc\"}"
        },
        {
          "inData": [
            "{\"a\", \"bb\", \"b\", \"ccc\"}",
            "3"
          ],
          "expectedValue": "{\"a\", \"bb\", \"b\"}"
        },
        {
          "inData": [
            "{\"a\", \"bb\", \"b\", \"ccc\"}",
            "4"
          ],
          "expectedValue": "{\"a\", \"bb\", \"b\", \"ccc\"}"
        },
        {
          "inData": [
            "{\"xx\", \"yyy\", \"x\", \"yy\", \"z\"}",
            "1"
          ],
          "expectedValue": "{\"xx\", \"yyy\", \"yy\"}"
        },
        {
          "inData": [
            "{\"xx\", \"yyy\", \"x\", \"yy\", \"z\"}",
            "2"
          ],
          "expectedValue": "{\"yyy\", \"x\", \"z\"}"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "hasOne",
    "description": "Given a positive int n, return true if it contains a 1 digit. Note: use % to get the rightmost digit, and / to discard the rightmost digit. ",
    "examples": "hasOne(10) → true hasOne(22) → false hasOne(220) → false\n",
    "template": "public boolean hasOne(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "22"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "220"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "212"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "211112"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "121121"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "222222"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "56156"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "56556"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "dividesSelf",
    "description": "We\u0027ll say that a positive int divides itself if every digit in the number divides into the number evenly. So for example 128 divides itself since 1, 2, and 8 all divide into 128 evenly. We\u0027ll say that 0 does not divide into anything evenly, so no number with a 0 digit divides itself. Note: use % to get the rightmost digit, and / to discard the rightmost digit. ",
    "examples": "dividesSelf(128) → true dividesSelf(12) → true dividesSelf(120) → false\n",
    "template": "public boolean dividesSelf(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "128"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "12"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "120"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "122"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "13"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "32"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "22"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "42"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "212"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "213"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "162"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "copyEvens",
    "description": "Given an array of positive ints, return a new array of length \"count\" containing the first even numbers from the original array. The original array will contain at least \"count\" even numbers. ",
    "examples": "copyEvens({3, 2, 4, 5, 8}, 2) → {2, 4} copyEvens({3, 2, 4, 5, 8}, 3) → {2, 4, 8} copyEvens({6, 1, 2, 4, 5, 8}, 3) → {6, 2, 4}\n",
    "template": "public int[] copyEvens(int[] nums, int count) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        },
        {
          "type": "int",
          "name": "count"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{3, 2, 4, 5, 8}",
            "2"
          ],
          "expectedValue": "{2, 4}"
        },
        {
          "inData": [
            "{3, 2, 4, 5, 8}",
            "3"
          ],
          "expectedValue": "{2, 4, 8}"
        },
        {
          "inData": [
            "{6, 1, 2, 4, 5, 8}",
            "3"
          ],
          "expectedValue": "{6, 2, 4}"
        },
        {
          "inData": [
            "{6, 1, 2, 4, 5, 8}",
            "4"
          ],
          "expectedValue": "{6, 2, 4, 8}"
        },
        {
          "inData": [
            "{3, 1, 4, 1, 5}",
            "1"
          ],
          "expectedValue": "{4}"
        },
        {
          "inData": [
            "{2}",
            "1"
          ],
          "expectedValue": "{2}"
        },
        {
          "inData": [
            "{6, 2, 4, 8}",
            "2"
          ],
          "expectedValue": "{6, 2}"
        },
        {
          "inData": [
            "{6, 2, 4, 8}",
            "3"
          ],
          "expectedValue": "{6, 2, 4}"
        },
        {
          "inData": [
            "{6, 2, 4, 8}",
            "4"
          ],
          "expectedValue": "{6, 2, 4, 8}"
        },
        {
          "inData": [
            "{1, 8, 4}",
            "1"
          ],
          "expectedValue": "{8}"
        },
        {
          "inData": [
            "{1, 8, 4}",
            "2"
          ],
          "expectedValue": "{8, 4}"
        },
        {
          "inData": [
            "{2, 8, 4}",
            "2"
          ],
          "expectedValue": "{2, 8}"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "copyEndy",
    "description": "We\u0027ll say that a positive int n is \"endy\" if it is in the range 0..10 or 90..100 (inclusive). Given an array of positive ints, return a new array of length \"count\" containing the first endy numbers from the original array. Decompose out a separate isEndy(int n) method to test if a number is endy. The original array will contain at least \"count\" endy numbers. ",
    "examples": "copyEndy({9, 11, 90, 22, 6}, 2) → {9, 90} copyEndy({9, 11, 90, 22, 6}, 3) → {9, 90, 6} copyEndy({12, 1, 1, 13, 0, 20}, 2) → {1, 1}\n",
    "template": "public int[] copyEndy(int[] nums, int count) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        },
        {
          "type": "int",
          "name": "count"
        }
      ],
      "returnType": "int[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{9, 11, 90, 22, 6}",
            "2"
          ],
          "expectedValue": "{9, 90}"
        },
        {
          "inData": [
            "{9, 11, 90, 22, 6}",
            "3"
          ],
          "expectedValue": "{9, 90, 6}"
        },
        {
          "inData": [
            "{12, 1, 1, 13, 0, 20}",
            "2"
          ],
          "expectedValue": "{1, 1}"
        },
        {
          "inData": [
            "{12, 1, 1, 13, 0, 20}",
            "3"
          ],
          "expectedValue": "{1, 1, 0}"
        },
        {
          "inData": [
            "{0}",
            "1"
          ],
          "expectedValue": "{0}"
        },
        {
          "inData": [
            "{10, 11, 90}",
            "2"
          ],
          "expectedValue": "{10, 90}"
        },
        {
          "inData": [
            "{90, 22, 100}",
            "2"
          ],
          "expectedValue": "{90, 100}"
        },
        {
          "inData": [
            "{12, 11, 10, 89, 101, 4}",
            "1"
          ],
          "expectedValue": "{10}"
        },
        {
          "inData": [
            "{13, 2, 2, 0}",
            "2"
          ],
          "expectedValue": "{2, 2}"
        },
        {
          "inData": [
            "{13, 2, 2, 0}",
            "3"
          ],
          "expectedValue": "{2, 2, 0}"
        },
        {
          "inData": [
            "{13, 2, 13, 2, 0, 30}",
            "2"
          ],
          "expectedValue": "{2, 2}"
        },
        {
          "inData": [
            "{13, 2, 13, 2, 0, 30}",
            "3"
          ],
          "expectedValue": "{2, 2, 0}"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "matchUp",
    "description": "Given 2 arrays that are the same length containing strings, compare the 1st string in one array to the 1st string in the other array, the 2nd to the 2nd and so on. Count the number of times that the 2 strings are non-empty and start with the same char. The strings may be any length, including 0. ",
    "examples": "matchUp({\"aa\", \"bb\", \"cc\"}, {\"aaa\", \"xx\", \"bb\"}) → 1 matchUp({\"aa\", \"bb\", \"cc\"}, {\"aaa\", \"b\", \"bb\"}) → 2 matchUp({\"aa\", \"bb\", \"cc\"}, {\"\", \"\", \"ccc\"}) → 1\n",
    "template": "public int matchUp(String[] a, String[] b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String[]",
          "name": "a"
        },
        {
          "type": "String[]",
          "name": "b"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{\"aa\", \"bb\", \"cc\"}",
            "{\"aaa\", \"xx\", \"bb\"}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{\"aa\", \"bb\", \"cc\"}",
            "{\"aaa\", \"b\", \"bb\"}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{\"aa\", \"bb\", \"cc\"}",
            "{\"\", \"\", \"ccc\"}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{\"\", \"\", \"ccc\"}",
            "{\"aa\", \"bb\", \"cc\"}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{\"\", \"\", \"\"}",
            "{\"\", \"bb\", \"cc\"}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{\"aa\", \"bb\", \"cc\"}",
            "{\"\", \"\", \"\"}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{\"aa\", \"\", \"ccc\"}",
            "{\"\", \"bb\", \"cc\"}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{\"x\", \"y\", \"z\"}",
            "{\"y\", \"z\", \"x\"}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{\"\", \"y\", \"z\"}",
            "{\"\", \"y\", \"x\"}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{\"x\", \"y\", \"z\"}",
            "{\"xx\", \"yyy\", \"zzz\"}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{\"x\", \"y\", \"z\"}",
            "{\"xx\", \"yyy\", \"\"}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{\"b\", \"x\", \"y\", \"z\"}",
            "{\"a\", \"xx\", \"yyy\", \"zzz\"}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{\"aaa\", \"bb\", \"c\"}",
            "{\"aaa\", \"xx\", \"bb\"}"
          ],
          "expectedValue": "1"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "scoreUp",
    "description": "The \"key\" array is an array containing the correct answers to an exam, like {\"a\", \"a\", \"b\", \"b\"}. the \"answers\" array contains a student\u0027s answers, with \"?\" representing a question left blank. The two arrays are not empty and are the same length. Return the score for this array of answers, giving +4 for each correct answer, -1 for each incorrect answer, and +0 for each blank answer. ",
    "examples": "scoreUp({\"a\", \"a\", \"b\", \"b\"}, {\"a\", \"c\", \"b\", \"c\"}) → 6 scoreUp({\"a\", \"a\", \"b\", \"b\"}, {\"a\", \"a\", \"b\", \"c\"}) → 11 scoreUp({\"a\", \"a\", \"b\", \"b\"}, {\"a\", \"a\", \"b\", \"b\"}) → 16\n",
    "template": "public int scoreUp(String[] key, String[] answers) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String[]",
          "name": "key"
        },
        {
          "type": "String[]",
          "name": "answers"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\"}",
            "{\"a\", \"c\", \"b\", \"c\"}"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\"}",
            "{\"a\", \"a\", \"b\", \"c\"}"
          ],
          "expectedValue": "11"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\"}",
            "{\"a\", \"a\", \"b\", \"b\"}"
          ],
          "expectedValue": "16"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\"}",
            "{\"?\", \"c\", \"b\", \"?\"}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\"}",
            "{\"?\", \"c\", \"?\", \"?\"}"
          ],
          "expectedValue": "-1"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\"}",
            "{\"c\", \"?\", \"b\", \"b\"}"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\"}",
            "{\"c\", \"?\", \"b\", \"?\"}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{\"a\", \"b\", \"c\"}",
            "{\"a\", \"c\", \"b\"}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\", \"c\", \"c\"}",
            "{\"a\", \"c\", \"a\", \"c\", \"a\", \"c\"}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\", \"c\", \"c\"}",
            "{\"a\", \"c\", \"?\", \"?\", \"a\", \"c\"}"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\", \"c\", \"c\"}",
            "{\"a\", \"c\", \"?\", \"?\", \"c\", \"c\"}"
          ],
          "expectedValue": "11"
        },
        {
          "inData": [
            "{\"a\", \"b\", \"c\"}",
            "{\"a\", \"b\", \"c\"}"
          ],
          "expectedValue": "12"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "wordsWithout",
    "description": "Given an array of strings, return a new array without the strings that are equal to the target string. One approach is to count the occurrences of the target string, make a new array of the correct length, and then copy over the correct strings. ",
    "examples": "wordsWithout({\"a\", \"b\", \"c\", \"a\"}, \"a\") → {\"b\", \"c\"} wordsWithout({\"a\", \"b\", \"c\", \"a\"}, \"b\") → {\"a\", \"c\", \"a\"} wordsWithout({\"a\", \"b\", \"c\", \"a\"}, \"c\") → {\"a\", \"b\", \"a\"}\n",
    "template": "public String[] wordsWithout(String[] words, String target) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String[]",
          "name": "words"
        },
        {
          "type": "String",
          "name": "target"
        }
      ],
      "returnType": "String[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{\"a\", \"b\", \"c\", \"a\"}",
            "a"
          ],
          "expectedValue": "{\"b\", \"c\"}"
        },
        {
          "inData": [
            "{\"a\", \"b\", \"c\", \"a\"}",
            "b"
          ],
          "expectedValue": "{\"a\", \"c\", \"a\"}"
        },
        {
          "inData": [
            "{\"a\", \"b\", \"c\", \"a\"}",
            "c"
          ],
          "expectedValue": "{\"a\", \"b\", \"a\"}"
        },
        {
          "inData": [
            "{\"b\", \"c\", \"a\", \"a\"}",
            "b"
          ],
          "expectedValue": "{\"c\", \"a\", \"a\"}"
        },
        {
          "inData": [
            "{\"xx\", \"yyy\", \"x\", \"yy\", \"x\"}",
            "x"
          ],
          "expectedValue": "{\"xx\", \"yyy\", \"yy\"}"
        },
        {
          "inData": [
            "{\"xx\", \"yyy\", \"x\", \"yy\", \"x\"}",
            "yy"
          ],
          "expectedValue": "{\"xx\", \"yyy\", \"x\", \"x\"}"
        },
        {
          "inData": [
            "{\"aa\", \"ab\", \"ac\", \"aa\"}",
            "aa"
          ],
          "expectedValue": "{\"ab\", \"ac\"}"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "scoresSpecial",
    "description": "Given two arrays, A and B, of non-negative int scores. A \"special\" score is one which is a multiple of 10, such as 40 or 90. Return the sum of largest special score in A and the largest special score in B. To practice decomposition, write a separate helper method which finds the largest special score in an array. Write your helper method after your scoresSpecial() method in the JavaBat text area. ",
    "examples": "scoresSpecial() method in the JavaBat text area. scoresSpecial({12, 10, 4}, {2, 20, 30}) → 40 scoresSpecial({20, 10, 4}, {2, 20, 10}) → 40 scoresSpecial({12, 11, 4}, {2, 20, 31}) → 20\n",
    "template": "public int scoresSpecial(int[] a, int[] b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "a"
        },
        {
          "type": "int[]",
          "name": "b"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{12, 10, 4}",
            "{2, 20, 30}"
          ],
          "expectedValue": "40"
        },
        {
          "inData": [
            "{20, 10, 4}",
            "{2, 20, 10}"
          ],
          "expectedValue": "40"
        },
        {
          "inData": [
            "{12, 11, 4}",
            "{2, 20, 31}"
          ],
          "expectedValue": "20"
        },
        {
          "inData": [
            "{1, 20, 2, 50}",
            "{3, 4, 5}"
          ],
          "expectedValue": "50"
        },
        {
          "inData": [
            "{3, 4, 5}",
            "{1, 50, 2, 20}"
          ],
          "expectedValue": "50"
        },
        {
          "inData": [
            "{10, 4, 20, 30}",
            "{20}"
          ],
          "expectedValue": "50"
        },
        {
          "inData": [
            "{10, 4, 20, 30}",
            "{20}"
          ],
          "expectedValue": "50"
        },
        {
          "inData": [
            "{10, 4, 20, 30}",
            "{3, 20, 99}"
          ],
          "expectedValue": "50"
        },
        {
          "inData": [
            "{10, 4, 20, 30}",
            "{30, 20, 99}"
          ],
          "expectedValue": "60"
        },
        {
          "inData": [
            "{}",
            "{2}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{}",
            "{20}"
          ],
          "expectedValue": "20"
        },
        {
          "inData": [
            "{14, 10, 4}",
            "{4, 20, 30}"
          ],
          "expectedValue": "40"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "sumHeights",
    "description": "We have an array of heights, representing the altitude along a walking trail. Given start/end indexes into the array, return the sum of the changes for a walk beginning at the start index and ending at the end index. For example, with the heights {5, 3, 6, 7, 2} and start\u003d2, end\u003d4 yields a sum of 1 + 5 \u003d 6. The start end end index will both be valid indexes into the array with start \u0026lt;\u003d end. ",
    "examples": "sumHeights({5, 3, 6, 7, 2}, 2, 4) → 6 sumHeights({5, 3, 6, 7, 2}, 0, 1) → 2 sumHeights({5, 3, 6, 7, 2}, 0, 4) → 11\n",
    "template": "public int sumHeights(int[] heights, int start, int end) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "heights"
        },
        {
          "type": "int",
          "name": "start"
        },
        {
          "type": "int",
          "name": "end"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{5, 3, 6, 7, 2}",
            "2",
            "4"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "{5, 3, 6, 7, 2}",
            "0",
            "1"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{5, 3, 6, 7, 2}",
            "0",
            "4"
          ],
          "expectedValue": "11"
        },
        {
          "inData": [
            "{5, 3, 6, 7, 2}",
            "1",
            "1"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "0",
            "3"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "4",
            "8"
          ],
          "expectedValue": "11"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "7",
            "8"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "8",
            "8"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "2",
            "2"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "3",
            "6"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{10, 8, 7, 7, 7, 6, 7}",
            "1",
            "4"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{10, 8, 7, 7, 7, 6, 7}",
            "1",
            "5"
          ],
          "expectedValue": "2"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "sumHeights2",
    "description": "(A variation on the sumHeights problem.) We have an array of heights, representing the altitude along a walking trail. Given start/end indexes into the array, return the sum of the changes for a walk beginning at the start index and ending at the end index, however increases in height count double. For example, with the heights {5, 3, 6, 7, 2} and start\u003d2, end\u003d4 yields a sum of 1*2 + 5 \u003d 7. The start end end index will both be valid indexes into the array with start \u0026lt;\u003d end. ",
    "examples": "sumHeights2({5, 3, 6, 7, 2}, 2, 4) → 7 sumHeights2({5, 3, 6, 7, 2}, 0, 1) → 2 sumHeights2({5, 3, 6, 7, 2}, 0, 4) → 15\n",
    "template": "public int sumHeights2(int[] heights, int start, int end) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "heights"
        },
        {
          "type": "int",
          "name": "start"
        },
        {
          "type": "int",
          "name": "end"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{5, 3, 6, 7, 2}",
            "2",
            "4"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "{5, 3, 6, 7, 2}",
            "0",
            "1"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{5, 3, 6, 7, 2}",
            "0",
            "4"
          ],
          "expectedValue": "15"
        },
        {
          "inData": [
            "{5, 3, 6, 7, 2}",
            "1",
            "1"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "0",
            "3"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "4",
            "8"
          ],
          "expectedValue": "19"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "7",
            "8"
          ],
          "expectedValue": "16"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "8",
            "8"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "2",
            "2"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "3",
            "6"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{10, 8, 7, 7, 7, 6, 7}",
            "1",
            "4"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{10, 8, 7, 7, 7, 6, 7}",
            "1",
            "5"
          ],
          "expectedValue": "2"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "bigHeights",
    "description": "(A variation on the sumHeights problem.) We have an array of heights, representing the altitude along a walking trail. Given start/end indexes into the array, return the number of \"big\" steps for a walk starting at the start index and ending at the end index. We\u0027ll say that step is big if it is 5 or more up or down. The start end end index will both be valid indexes into the array with start \u0026lt;\u003d end. ",
    "examples": "bigHeights({5, 3, 6, 7, 2}, 2, 4) → 1 bigHeights({5, 3, 6, 7, 2}, 0, 1) → 0 bigHeights({5, 3, 6, 7, 2}, 0, 4) → 1\n",
    "template": "public int bigHeights(int[] heights, int start, int end) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "heights"
        },
        {
          "type": "int",
          "name": "start"
        },
        {
          "type": "int",
          "name": "end"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{5, 3, 6, 7, 2}",
            "2",
            "4"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{5, 3, 6, 7, 2}",
            "0",
            "1"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{5, 3, 6, 7, 2}",
            "0",
            "4"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{5, 3, 6, 7, 3}",
            "0",
            "4"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{5, 3, 6, 7, 2}",
            "1",
            "1"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{5, 13, 6, 7, 2}",
            "1",
            "2"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{5, 13, 6, 7, 2}",
            "0",
            "2"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{5, 13, 6, 7, 2}",
            "1",
            "4"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{5, 13, 6, 7, 2}",
            "0",
            "4"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{5, 13, 6, 7, 2}",
            "0",
            "3"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "0",
            "3"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 4, 3, 2, 10}",
            "4",
            "8"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{1, 2, 3, 14, 5, 4, 3, 2, 10}",
            "0",
            "3"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{1, 2, 3, 14, 5, 4, 3, 2, 10}",
            "7",
            "8"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{1, 2, 3, 14, 5, 4, 3, 2, 10}",
            "3",
            "8"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 2, 3, 14, 5, 4, 3, 2, 10}",
            "2",
            "8"
          ],
          "expectedValue": "3"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "userCompare",
    "description": "We have data for two users, A and B, each with a String name and an int id. The goal is to order the users such as for sorting. Return -1 if A comes before B, 1 if A comes after B, and 0 if they are the same. Order first by the string names, and then by the id numbers if the names are the same. Note: with Strings str1.compareTo(str2) returns an int value which is negative/0/positive to indicate how str1 is ordered to str2 (the value is not limited to -1/0/1). (On the AP, there would be two User objects, but here the code simply takes the two strings and two ints directly. The code logic is the same.) ",
    "examples": "userCompare(\"bb\", 1, \"zz\", 2) → -1 userCompare(\"bb\", 1, \"aa\", 2) → 1 userCompare(\"bb\", 1, \"bb\", 1) → 0\n",
    "template": "public int userCompare(String aName, int aId, String bName, int bId) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "aName"
        },
        {
          "type": "int",
          "name": "aId"
        },
        {
          "type": "String",
          "name": "bName"
        },
        {
          "type": "int",
          "name": "bId"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "bb",
            "1",
            "zz",
            "2"
          ],
          "expectedValue": "-1"
        },
        {
          "inData": [
            "bb",
            "1",
            "aa",
            "2"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "bb",
            "1",
            "bb",
            "1"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "bb",
            "5",
            "bb",
            "1"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "bb",
            "5",
            "bb",
            "10"
          ],
          "expectedValue": "-1"
        },
        {
          "inData": [
            "adam",
            "1",
            "bob",
            "2"
          ],
          "expectedValue": "-1"
        },
        {
          "inData": [
            "bob",
            "1",
            "bob",
            "2"
          ],
          "expectedValue": "-1"
        },
        {
          "inData": [
            "bzb",
            "1",
            "bob",
            "2"
          ],
          "expectedValue": "1"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "mergeTwo",
    "description": "Start with two arrays of strings, A and B, each with its elements in alphabetical order and without duplicates. Return a new array containing the first N elements from the two arrays. The result array should be in alphabetical order and without duplicates. A and B will both have a length which is N or more. The best \"linear\" solution makes a single pass over A and B, taking advantage of the fact that they are in alphabetical order, copying elements directly to the new array. ",
    "examples": "mergeTwo({\"a\", \"c\", \"z\"}, {\"b\", \"f\", \"z\"}, 3) → {\"a\", \"b\", \"c\"} mergeTwo({\"a\", \"c\", \"z\"}, {\"c\", \"f\", \"z\"}, 3) → {\"a\", \"c\", \"f\"} mergeTwo({\"f\", \"g\", \"z\"}, {\"c\", \"f\", \"g\"}, 3) → {\"c\", \"f\", \"g\"}\n",
    "template": "public String[] mergeTwo(String[] a, String[] b, int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String[]",
          "name": "a"
        },
        {
          "type": "String[]",
          "name": "b"
        },
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "String[]"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{\"a\", \"c\", \"z\"}",
            "{\"b\", \"f\", \"z\"}",
            "3"
          ],
          "expectedValue": "{\"a\", \"b\", \"c\"}"
        },
        {
          "inData": [
            "{\"a\", \"c\", \"z\"}",
            "{\"c\", \"f\", \"z\"}",
            "3"
          ],
          "expectedValue": "{\"a\", \"c\", \"f\"}"
        },
        {
          "inData": [
            "{\"f\", \"g\", \"z\"}",
            "{\"c\", \"f\", \"g\"}",
            "3"
          ],
          "expectedValue": "{\"c\", \"f\", \"g\"}"
        },
        {
          "inData": [
            "{\"a\", \"c\", \"z\"}",
            "{\"a\", \"c\", \"z\"}",
            "3"
          ],
          "expectedValue": "{\"a\", \"c\", \"z\"}"
        },
        {
          "inData": [
            "{\"a\", \"b\", \"c\", \"z\"}",
            "{\"a\", \"c\", \"z\"}",
            "3"
          ],
          "expectedValue": "{\"a\", \"b\", \"c\"}"
        },
        {
          "inData": [
            "{\"a\", \"c\", \"z\"}",
            "{\"a\", \"b\", \"c\", \"z\"}",
            "3"
          ],
          "expectedValue": "{\"a\", \"b\", \"c\"}"
        },
        {
          "inData": [
            "{\"a\", \"c\", \"z\"}",
            "{\"a\", \"c\", \"z\"}",
            "2"
          ],
          "expectedValue": "{\"a\", \"c\"}"
        },
        {
          "inData": [
            "{\"a\", \"c\", \"z\"}",
            "{\"a\", \"c\", \"y\", \"z\"}",
            "3"
          ],
          "expectedValue": "{\"a\", \"c\", \"y\"}"
        },
        {
          "inData": [
            "{\"x\", \"y\", \"z\"}",
            "{\"a\", \"b\", \"z\"}",
            "3"
          ],
          "expectedValue": "{\"a\", \"b\", \"x\"}"
        }
      ]
    }
  },
  {
    "groupName": "AP-1",
    "title": "commonTwo",
    "description": "Start with two arrays of strings, a and b, each in alphabetical order, possibly with duplicates. Return the count of the number of strings which appear in both arrays. The best \"linear\" solution makes a single pass over both arrays, taking advantage of the fact that they are in alphabetical order. ",
    "examples": "commonTwo({\"a\", \"c\", \"x\"}, {\"b\", \"c\", \"d\", \"x\"}) → 2 commonTwo({\"a\", \"c\", \"x\"}, {\"a\", \"b\", \"c\", \"x\", \"z\"}) → 3 commonTwo({\"a\", \"b\", \"c\"}, {\"a\", \"b\", \"c\"}) → 3\n",
    "template": "public int commonTwo(String[] a, String[] b) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String[]",
          "name": "a"
        },
        {
          "type": "String[]",
          "name": "b"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{\"a\", \"c\", \"x\"}",
            "{\"b\", \"c\", \"d\", \"x\"}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{\"a\", \"c\", \"x\"}",
            "{\"a\", \"b\", \"c\", \"x\", \"z\"}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{\"a\", \"b\", \"c\"}",
            "{\"a\", \"b\", \"c\"}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\", \"c\"}",
            "{\"a\", \"b\", \"c\"}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\", \"c\"}",
            "{\"a\", \"b\", \"b\", \"b\", \"c\"}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\", \"c\"}",
            "{\"a\", \"b\", \"b\", \"c\", \"c\"}"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{\"b\", \"b\", \"b\", \"b\", \"c\"}",
            "{\"a\", \"b\", \"b\", \"b\", \"c\"}"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{\"a\", \"b\", \"c\", \"c\", \"d\"}",
            "{\"a\", \"b\", \"b\", \"c\", \"d\", \"d\"}"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\", \"c\"}",
            "{\"b\", \"b\", \"b\"}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\", \"c\"}",
            "{\"c\", \"c\"}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\", \"c\"}",
            "{\"b\", \"b\", \"b\", \"x\"}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{\"a\", \"a\", \"b\", \"b\", \"c\"}",
            "{\"b\", \"b\"}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{\"a\"}",
            "{\"a\", \"b\"}"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{\"a\"}",
            "{\"b\"}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{\"a\", \"a\"}",
            "{\"b\", \"b\"}"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{\"a\", \"b\"}",
            "{\"a\", \"b\"}"
          ],
          "expectedValue": "2"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "factorial",
    "description": "Given n of 1 or more, return the factorial of n, which is n * (n-1) * (n-2) ... 1. Compute the result recursively (without loops). ",
    "examples": "factorial of n, which is n * (n-1) * (n-2) ... 1. Compute the result recursively (without loops). factorial(1) → 1 factorial(2) → 2 factorial(3) → 6\n",
    "template": "public int factorial(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "1"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "2"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "3"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "4"
          ],
          "expectedValue": "24"
        },
        {
          "inData": [
            "5"
          ],
          "expectedValue": "120"
        },
        {
          "inData": [
            "6"
          ],
          "expectedValue": "720"
        },
        {
          "inData": [
            "7"
          ],
          "expectedValue": "5040"
        },
        {
          "inData": [
            "8"
          ],
          "expectedValue": "40320"
        },
        {
          "inData": [
            "12"
          ],
          "expectedValue": "479001600"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "bunnyEars",
    "description": "We have a number of bunnies and each bunny has two big floppy ears. We want to compute the total number of ears across all the bunnies recursively (without loops or multiplication). ",
    "examples": "bunnyEars(0) → 0 bunnyEars(1) → 2 bunnyEars(2) → 4\n",
    "template": "public int bunnyEars(int bunnies) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "bunnies"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "0"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "2"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "3"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "4"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "5"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "12"
          ],
          "expectedValue": "24"
        },
        {
          "inData": [
            "50"
          ],
          "expectedValue": "100"
        },
        {
          "inData": [
            "234"
          ],
          "expectedValue": "468"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "fibonacci",
    "description": "The fibonacci sequence is a famous bit of mathematics, and it happens to have a recursive definition. The first two values in the sequence are 0 and 1 (essentially 2 base cases). Each subsequent value is the sum of the previous two values, so the whole sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21 and so on. Define a recursive fibonacci(n) method that returns the nth fibonacci number, with n\u003d0 representing the start of the sequence. ",
    "examples": "fibonacci sequence is a famous bit of mathematics, and it happens to have a recursive definition. The first two values in the sequence are 0 and 1 (essentially 2 base cases). Each subsequent value is the sum of the previous two values, so the whole sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21 and so on. Define a recursive fibonacci(n) method that returns the nth fibonacci number, with n\u003d0 representing the start of the sequence. fibonacci(0) → 0 fibonacci(1) → 1 fibonacci(2) → 1\n",
    "template": "public int fibonacci(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "0"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "2"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "3"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "4"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "5"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "6"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "7"
          ],
          "expectedValue": "13"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "bunnyEars2",
    "description": "We have bunnies standing in a line, numbered 1, 2, ... The odd bunnies (1, 3, ..) have the normal 2 ears. The even bunnies (2, 4, ..) we\u0027ll say have 3 ears, because they each have a raised foot. Recursively return the number of \"ears\" in the bunny line 1, 2, ... n (without loops or multiplication). ",
    "examples": "bunnyEars2(0) → 0 bunnyEars2(1) → 2 bunnyEars2(2) → 5\n",
    "template": "public int bunnyEars2(int bunnies) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "bunnies"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "0"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "2"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "3"
          ],
          "expectedValue": "7"
        },
        {
          "inData": [
            "4"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "5"
          ],
          "expectedValue": "12"
        },
        {
          "inData": [
            "6"
          ],
          "expectedValue": "15"
        },
        {
          "inData": [
            "10"
          ],
          "expectedValue": "25"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "triangle",
    "description": "We have triangle made of blocks. The topmost row has 1 block, the next row down has 2 blocks, the next row has 3 blocks, and so on. Compute recursively (no loops or multiplication) the total number of blocks in such a triangle with the given number of rows. ",
    "examples": "triangle made of blocks. The topmost row has 1 block, the next row down has 2 blocks, the next row has 3 blocks, and so on. Compute recursively (no loops or multiplication) the total number of blocks in such a triangle with the given number of rows. triangle(0) → 0 triangle(1) → 1 triangle(2) → 3\n",
    "template": "public int triangle(int rows) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "rows"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "0"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "2"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "3"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "4"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "5"
          ],
          "expectedValue": "15"
        },
        {
          "inData": [
            "6"
          ],
          "expectedValue": "21"
        },
        {
          "inData": [
            "7"
          ],
          "expectedValue": "28"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "sumDigits",
    "description": "Given a non-negative int n, return the sum of its digits recursively (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12). ",
    "examples": "sumDigits(126) → 9 sumDigits(49) → 13 sumDigits(12) → 3\n",
    "template": "public int sumDigits(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "126"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "49"
          ],
          "expectedValue": "13"
        },
        {
          "inData": [
            "12"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "10"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "0"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "730"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "1111"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "11111"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "10110"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "235"
          ],
          "expectedValue": "10"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "count7",
    "description": "Given a non-negative int n, return the count of the occurrences of 7 as a digit, so for example 717 yields 2. (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12). ",
    "examples": "count7(717) → 2 count7(7) → 1 count7(123) → 0\n",
    "template": "public int count7(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "717"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "7"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "123"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "77"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "7123"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "771237"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "771737"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "47571"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "777777"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "70701277"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "777576197"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "99999"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "99799"
          ],
          "expectedValue": "1"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "count8",
    "description": "Given a non-negative int n, compute recursively (no loops) the count of the occurrences of 8 as a digit, except that an 8 with another 8 immediately to its left counts double, so 8818 yields 4. Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12). ",
    "examples": "count8(8) → 1 count8(818) → 2 count8(8818) → 4\n",
    "template": "public int count8(int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "8"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "818"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "8818"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "8088"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "123"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "81238"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "88788"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "8234"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "2348"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "23884"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "0"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "1818188"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "8818181"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "1080"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "188"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "88888"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "9898"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "78"
          ],
          "expectedValue": "1"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "powerN",
    "description": "Given \u003cb\u003ebase\u003c/b\u003e and \u003cb\u003en\u003c/b\u003e that are both 1 or more, compute recursively (no loops) the value of base to the n power, so powerN(3, 2) is 9 (3 squared). ",
    "examples": "powerN(3, 2) is 9 (3 squared). powerN(3, 1) → 3 powerN(3, 2) → 9 powerN(3, 3) → 27\n",
    "template": "public int powerN(int base, int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "base"
        },
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "3",
            "1"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "3",
            "2"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "3",
            "3"
          ],
          "expectedValue": "27"
        },
        {
          "inData": [
            "2",
            "1"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "2",
            "2"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "2",
            "3"
          ],
          "expectedValue": "8"
        },
        {
          "inData": [
            "2",
            "4"
          ],
          "expectedValue": "16"
        },
        {
          "inData": [
            "2",
            "5"
          ],
          "expectedValue": "32"
        },
        {
          "inData": [
            "10",
            "1"
          ],
          "expectedValue": "10"
        },
        {
          "inData": [
            "10",
            "2"
          ],
          "expectedValue": "100"
        },
        {
          "inData": [
            "10",
            "3"
          ],
          "expectedValue": "1000"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "countX",
    "description": "Given a string, compute recursively (no loops) the number of lowercase \u0027x\u0027 chars in the string. ",
    "examples": "countX(\"xxhixx\") → 4 countX(\"xhixhix\") → 3 countX(\"hi\") → 0\n",
    "template": "public int countX(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "xxhixx"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "xhixhix"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "hi"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "h"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "hihi"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "hiAAhi12hi"
          ],
          "expectedValue": "0"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "countHi",
    "description": "Given a string, compute recursively (no loops) the number of times lowercase \"hi\" appears in the string. ",
    "examples": "countHi(\"xxhixx\") → 1 countHi(\"xhixhix\") → 2 countHi(\"hi\") → 1\n",
    "template": "public int countHi(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "xxhixx"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "xhixhix"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "hi"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "hihih"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "h"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "ihihihihih"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "ihihihihihi"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "hiAAhi12hi"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "xhixhxihihhhih"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "ship"
          ],
          "expectedValue": "1"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "changeXY",
    "description": "Given a string, compute recursively (no loops) a new string where all the lowercase \u0027x\u0027 chars have been changed to \u0027y\u0027 chars. ",
    "examples": "changeXY(\"codex\") → \"codey\" changeXY(\"xxhixx\") → \"yyhiyy\" changeXY(\"xhixhix\") → \"yhiyhiy\"\n",
    "template": "public String changeXY(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "codex"
          ],
          "expectedValue": "codey"
        },
        {
          "inData": [
            "xxhixx"
          ],
          "expectedValue": "yyhiyy"
        },
        {
          "inData": [
            "xhixhix"
          ],
          "expectedValue": "yhiyhiy"
        },
        {
          "inData": [
            "hiy"
          ],
          "expectedValue": "hiy"
        },
        {
          "inData": [
            "h"
          ],
          "expectedValue": "h"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "y"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "xxx"
          ],
          "expectedValue": "yyy"
        },
        {
          "inData": [
            "yyhxyi"
          ],
          "expectedValue": "yyhyyi"
        },
        {
          "inData": [
            "hihi"
          ],
          "expectedValue": "hihi"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "changePi",
    "description": "Given a string, compute recursively (no loops) a new string where all appearances of \"pi\" have been replaced by \"3.14\". ",
    "examples": "changePi(\"xpix\") → \"x3.14x\" changePi(\"pipi\") → \"3.143.14\" changePi(\"pip\") → \"3.14p\"\n",
    "template": "public String changePi(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "xpix"
          ],
          "expectedValue": "x3.14x"
        },
        {
          "inData": [
            "pipi"
          ],
          "expectedValue": "3.143.14"
        },
        {
          "inData": [
            "pip"
          ],
          "expectedValue": "3.14p"
        },
        {
          "inData": [
            "pi"
          ],
          "expectedValue": "3.14"
        },
        {
          "inData": [
            "hip"
          ],
          "expectedValue": "hip"
        },
        {
          "inData": [
            "p"
          ],
          "expectedValue": "p"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "x"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "pixx"
          ],
          "expectedValue": "3.14xx"
        },
        {
          "inData": [
            "xyzzy"
          ],
          "expectedValue": "xyzzy"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "noX",
    "description": "Given a string, compute recursively a new string where all the \u0027x\u0027 chars have been removed. ",
    "examples": "noX(\"xaxb\") → \"ab\" noX(\"abc\") → \"abc\" noX(\"xx\") → \"\"\n",
    "template": "public String noX(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "xaxb"
          ],
          "expectedValue": "ab"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "abc"
        },
        {
          "inData": [
            "xx"
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "axxbxx"
          ],
          "expectedValue": "ab"
        },
        {
          "inData": [
            "Hellox"
          ],
          "expectedValue": "Hello"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "array6",
    "description": "Given an array of ints, compute recursively if the array contains a 6. We\u0027ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0. ",
    "examples": "array6({1, 6, 4}, 0) → true array6({1, 4}, 0) → false array6({6}, 0) → true\n",
    "template": "public boolean array6(int[] nums, int index) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        },
        {
          "type": "int",
          "name": "index"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 6, 4}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 4}",
            "0"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{6}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{}",
            "0"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{6, 2, 2}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 5}",
            "0"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 9, 4, 6, 6}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 5, 6}",
            "0"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "array11",
    "description": "Given an array of ints, compute recursively the number of times that the value 11 appears in the array. We\u0027ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0. ",
    "examples": "array11({1, 2, 11}, 0) → 1 array11({11, 11}, 0) → 2 array11({1, 2, 3, 4}, 0) → 0\n",
    "template": "public int array11(int[] nums, int index) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        },
        {
          "type": "int",
          "name": "index"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 11}",
            "0"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{11, 11}",
            "0"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{1, 2, 3, 4}",
            "0"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{1, 11, 3, 11, 11}",
            "0"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "{11}",
            "0"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "{1}",
            "0"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{}",
            "0"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "{11, 2, 3, 4, 11, 5}",
            "0"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "{11, 5, 11}",
            "0"
          ],
          "expectedValue": "2"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "array220",
    "description": "Given an array of ints, compute recursively if the array contains somewhere a value followed in the array by that value times 10. We\u0027ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0. ",
    "examples": "array220({1, 2, 20}, 0) → true array220({3, 30}, 0) → true array220({3}, 0) → false\n",
    "template": "public boolean array220(int[] nums, int index) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        },
        {
          "type": "int",
          "name": "index"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1, 2, 20}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 30}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3}",
            "0"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{}",
            "0"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 3, 30, 4}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 19, 4}",
            "0"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{20, 2, 21}",
            "0"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{20, 2, 21, 210}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 200, 2000}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{0, 0}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 6}",
            "0"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 50, 6}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 5, 51, 6}",
            "0"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 2, 3, 4, 4, 50, 500, 6}",
            "0"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "allStar",
    "description": "Given a string, compute recursively a new string where all the adjacent chars are now separated by a \"*\". ",
    "examples": "allStar(\"hello\") → \"h*e*l*l*o\" allStar(\"abc\") → \"a*b*c\" allStar(\"ab\") → \"a*b\"\n",
    "template": "public String allStar(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "hello"
          ],
          "expectedValue": "h*e*l*l*o"
        },
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "a*b*c"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "a*b"
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": "a"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "3.14"
          ],
          "expectedValue": "3*.*1*4"
        },
        {
          "inData": [
            "Chocolate"
          ],
          "expectedValue": "C*h*o*c*o*l*a*t*e"
        },
        {
          "inData": [
            "1234"
          ],
          "expectedValue": "1*2*3*4"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "pairStar",
    "description": "Given a string, compute recursively a new string where identical chars that are adjacent in the original string are separated from each other by a \"*\". ",
    "examples": "pairStar(\"hello\") → \"hel*lo\" pairStar(\"xxyy\") → \"x*xy*y\" pairStar(\"aaaa\") → \"a*a*a*a\"\n",
    "template": "public String pairStar(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "hello"
          ],
          "expectedValue": "hel*lo"
        },
        {
          "inData": [
            "xxyy"
          ],
          "expectedValue": "x*xy*y"
        },
        {
          "inData": [
            "aaaa"
          ],
          "expectedValue": "a*a*a*a"
        },
        {
          "inData": [
            "aaab"
          ],
          "expectedValue": "a*a*ab"
        },
        {
          "inData": [
            "aa"
          ],
          "expectedValue": "a*a"
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": "a"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "noadjacent"
          ],
          "expectedValue": "noadjacent"
        },
        {
          "inData": [
            "abba"
          ],
          "expectedValue": "ab*ba"
        },
        {
          "inData": [
            "abbba"
          ],
          "expectedValue": "ab*b*ba"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "endX",
    "description": "Given a string, compute recursively a new string where all the lowercase \u0027x\u0027 chars have been moved to the end of the string. ",
    "examples": "endX(\"xxre\") → \"rexx\" endX(\"xxhixx\") → \"hixxxx\" endX(\"xhixhix\") → \"hihixxx\"\n",
    "template": "public String endX(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "xxre"
          ],
          "expectedValue": "rexx"
        },
        {
          "inData": [
            "xxhixx"
          ],
          "expectedValue": "hixxxx"
        },
        {
          "inData": [
            "xhixhix"
          ],
          "expectedValue": "hihixxx"
        },
        {
          "inData": [
            "hiy"
          ],
          "expectedValue": "hiy"
        },
        {
          "inData": [
            "h"
          ],
          "expectedValue": "h"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "x"
        },
        {
          "inData": [
            "xx"
          ],
          "expectedValue": "xx"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": ""
        },
        {
          "inData": [
            "bxx"
          ],
          "expectedValue": "bxx"
        },
        {
          "inData": [
            "bxax"
          ],
          "expectedValue": "baxx"
        },
        {
          "inData": [
            "axaxax"
          ],
          "expectedValue": "aaaxxx"
        },
        {
          "inData": [
            "xxhxi"
          ],
          "expectedValue": "hixxx"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "countPairs",
    "description": "We\u0027ll say that a \"pair\" in a string is two instances of a char separated by a char. So \"AxA\" the A\u0027s make a pair. Pair\u0027s can overlap, so \"AxAxA\" contains 3 pairs -- 2 for A and 1 for x. Recursively compute the number of pairs in the given string. ",
    "examples": "countPairs(\"axa\") → 1 countPairs(\"axax\") → 2 countPairs(\"axbx\") → 1\n",
    "template": "public int countPairs(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "axa"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "axax"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "axbx"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "hi"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "hihih"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "ihihhh"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "ihjxhh"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "a"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "aa"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "aaa"
          ],
          "expectedValue": "1"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "countAbc",
    "description": "Count recursively the total number of \"abc\" and \"aba\" substrings that appear in the given string. ",
    "examples": "countAbc(\"abc\") → 1 countAbc(\"abcxxabc\") → 2 countAbc(\"abaxxaba\") → 2\n",
    "template": "public int countAbc(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "abc"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "abcxxabc"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "abaxxaba"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "ababc"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "abxbc"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "aaabc"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "hello"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "ab"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "aba"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "aca"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "aaa"
          ],
          "expectedValue": "0"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "count11",
    "description": "Given a string, compute recursively (no loops) the number of \"11\" substrings in the string. The \"11\" substrings should not overlap. ",
    "examples": "count11(\"11abc11\") → 2 count11(\"abc11x11x11\") → 3 count11(\"111\") → 1\n",
    "template": "public int count11(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "11abc11"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "abc11x11x11"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "111"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "1111"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "1"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "hi"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "11x111x1111"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "1x111"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "1Hello1"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "0"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "stringClean",
    "description": "Given a string, return recursively a \"cleaned\" string where adjacent chars that are the same have been reduced to a single char. So \"yyzzza\" yields \"yza\". ",
    "examples": "stringClean(\"yyzzza\") → \"yza\" stringClean(\"abbbcdd\") → \"abcd\" stringClean(\"Hello\") → \"Helo\"\n",
    "template": "public String stringClean(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "yyzzza"
          ],
          "expectedValue": "yza"
        },
        {
          "inData": [
            "abbbcdd"
          ],
          "expectedValue": "abcd"
        },
        {
          "inData": [
            "Hello"
          ],
          "expectedValue": "Helo"
        },
        {
          "inData": [
            "XXabcYY"
          ],
          "expectedValue": "XabcY"
        },
        {
          "inData": [
            "112ab445"
          ],
          "expectedValue": "12ab45"
        },
        {
          "inData": [
            "Hello Bookkeeper"
          ],
          "expectedValue": "Helo Bokeper"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "countHi2",
    "description": "Given a string, compute recursively the number of times lowercase \"hi\" appears in the string, however do not count \"hi\" that have an \u0027x\u0027 immedately before them. ",
    "examples": "countHi2(\"ahixhi\") → 1 countHi2(\"ahibhi\") → 2 countHi2(\"xhixhi\") → 0\n",
    "template": "public int countHi2(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "ahixhi"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "ahibhi"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "xhixhi"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "hixhi"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "hixhhi"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "hihihi"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "hihihix"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "xhihihix"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "xxhi"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "hixxhi"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "hi"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "xxxx"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "h"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "x"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "Hellohi"
          ],
          "expectedValue": "1"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "parenBit",
    "description": "Given a string that contains a single pair of parenthesis, compute recursively a new string made of only of the parenthesis and their contents, so \"xyz(abc)123\" yields \"(abc)\". ",
    "examples": "parenBit(\"xyz(abc)123\") → \"(abc)\" parenBit(\"x(hello)\") → \"(hello)\" parenBit(\"(xy)1\") → \"(xy)\"\n",
    "template": "public String parenBit(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "String"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "",
            "xyz(abc"
          ],
          "expectedValue": "(abc)"
        },
        {
          "inData": [
            "",
            "x(hello"
          ],
          "expectedValue": "(hello)"
        },
        {
          "inData": [
            "",
            "(xy"
          ],
          "expectedValue": "(xy)"
        },
        {
          "inData": [
            "",
            "not really (possible"
          ],
          "expectedValue": "(possible)"
        },
        {
          "inData": [
            "",
            "(abc"
          ],
          "expectedValue": "(abc)"
        },
        {
          "inData": [
            "",
            "(abc"
          ],
          "expectedValue": "(abc)"
        },
        {
          "inData": [
            "",
            "(abc"
          ],
          "expectedValue": "(abc)"
        },
        {
          "inData": [
            "",
            "(x"
          ],
          "expectedValue": "(x)"
        },
        {
          "inData": [
            "",
            "("
          ],
          "expectedValue": "()"
        },
        {
          "inData": [
            "",
            "res (ipsa"
          ],
          "expectedValue": "(ipsa)"
        },
        {
          "inData": [
            "",
            "hello(not really"
          ],
          "expectedValue": "(not really)"
        },
        {
          "inData": [
            "",
            "ab(ab"
          ],
          "expectedValue": "(ab)"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "nestParen",
    "description": "Given a string, return true if it is a nesting of zero or more pairs of parenthesis, like \"(())\" or \"((()))\". Suggestion: check the first and last chars, and then recur on what\u0027s inside them. ",
    "examples": "nestParen(\"(())\") → true nestParen(\"((()))\") → true nestParen(\"(((x))\") → false\n",
    "template": "public boolean nestParen(String str) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "",
            "(("
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "",
            "((("
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "",
            "(((x"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "",
            "((("
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "",
            "((("
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "",
            "("
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            ""
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "",
            "(yy"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "",
            "(("
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "",
            "(((y"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "",
            "((y"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "",
            "((("
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "",
            "(("
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "",
            "((yy("
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "",
            "(((("
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "strCount",
    "description": "Given a string and a non-empty substring \u003cb\u003esub\u003c/b\u003e, compute recursively the number of times that sub appears in the string, without the sub strings overlapping. ",
    "examples": "strCount(\"catcowcat\", \"cat\") → 2 strCount(\"catcowcat\", \"cow\") → 1 strCount(\"catcowcat\", \"dog\") → 0\n",
    "template": "public int strCount(String str, String sub) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "String",
          "name": "sub"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "catcowcat",
            "cat"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "catcowcat",
            "cow"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "catcowcat",
            "dog"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "cacatcowcat",
            "cat"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "xyx",
            "x"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "iiiijj",
            "i"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "iiiijj",
            "ii"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "iiiijj",
            "iii"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "iiiijj",
            "j"
          ],
          "expectedValue": "2"
        },
        {
          "inData": [
            "iiiijj",
            "jj"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "aaabababab",
            "ab"
          ],
          "expectedValue": "4"
        },
        {
          "inData": [
            "aaabababab",
            "aa"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "aaabababab",
            "a"
          ],
          "expectedValue": "6"
        },
        {
          "inData": [
            "aaabababab",
            "b"
          ],
          "expectedValue": "4"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "strCopies",
    "description": "Given a string and a non-empty substring \u003cb\u003esub\u003c/b\u003e, compute recursively if at least n copies of sub appear in the string somewhere, possibly with overlapping. N will be non-negative. ",
    "examples": "strCopies(\"catcowcat\", \"cat\", 2) → true strCopies(\"catcowcat\", \"cow\", 2) → false strCopies(\"catcowcat\", \"cow\", 1) → true\n",
    "template": "public boolean strCopies(String str, String sub, int n) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "String",
          "name": "sub"
        },
        {
          "type": "int",
          "name": "n"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "catcowcat",
            "cat",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "catcowcat",
            "cow",
            "2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "catcowcat",
            "cow",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "iiijjj",
            "i",
            "3"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "iiijjj",
            "i",
            "4"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "iiijjj",
            "ii",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "iiijjj",
            "ii",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "iiijjj",
            "x",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "iiijjj",
            "x",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "iiiiij",
            "iii",
            "3"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "iiiiij",
            "iii",
            "4"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "ijiiiiij",
            "iiii",
            "2"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "ijiiiiij",
            "iiii",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "dogcatdogcat",
            "dog",
            "2"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-1",
    "title": "strDist",
    "description": "Given a string and a non-empty substring \u003cb\u003esub\u003c/b\u003e, compute recursively the largest substring which starts and ends with sub and return its length. ",
    "examples": "strDist(\"catcowcat\", \"cat\") → 9 strDist(\"catcowcat\", \"cow\") → 3 strDist(\"cccatcowcatxx\", \"cat\") → 9\n",
    "template": "public int strDist(String str, String sub) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "String",
          "name": "str"
        },
        {
          "type": "String",
          "name": "sub"
        }
      ],
      "returnType": "int"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "catcowcat",
            "cat"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "catcowcat",
            "cow"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "cccatcowcatxx",
            "cat"
          ],
          "expectedValue": "9"
        },
        {
          "inData": [
            "abccatcowcatcatxyz",
            "cat"
          ],
          "expectedValue": "12"
        },
        {
          "inData": [
            "xyx",
            "x"
          ],
          "expectedValue": "3"
        },
        {
          "inData": [
            "xyx",
            "y"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "xyx",
            "z"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "z",
            "z"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "x",
            "z"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "",
            "z"
          ],
          "expectedValue": "0"
        },
        {
          "inData": [
            "hiHellohihihi",
            "hi"
          ],
          "expectedValue": "13"
        },
        {
          "inData": [
            "hiHellohihihi",
            "hih"
          ],
          "expectedValue": "5"
        },
        {
          "inData": [
            "hiHellohihihi",
            "o"
          ],
          "expectedValue": "1"
        },
        {
          "inData": [
            "hiHellohihihi",
            "ll"
          ],
          "expectedValue": "2"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-2",
    "title": "groupSum",
    "description": "Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target? This is a classic backtracking recursion problem. Once you understand the recursive backtracking strategy in this problem, you can use the same pattern for many problems to search a space of choices. Rather than looking at the whole array, our convention is to consider the part of the array starting at index \u003cb\u003estart\u003c/b\u003e and continuing to the end of the array. The caller can specify the whole array simply by passing start as 0. No loops are needed -- the recursive calls progress down the array. ",
    "examples": "groupSum(0, {2, 4, 8}, 10) → true groupSum(0, {2, 4, 8}, 14) → true groupSum(0, {2, 4, 8}, 9) → false\n",
    "template": "public boolean groupSum(int start, int[] nums, int target) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "start"
        },
        {
          "type": "int[]",
          "name": "nums"
        },
        {
          "type": "int",
          "name": "target"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "0",
            "{2, 4, 8}",
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{2, 4, 8}",
            "14"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{2, 4, 8}",
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{2, 4, 8}",
            "8"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "{2, 4, 8}",
            "8"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "1",
            "{2, 4, 8}",
            "2"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{1}",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{9}",
            "1"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "1",
            "{9}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{10, 2, 2, 5}",
            "17"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{10, 2, 2, 5}",
            "15"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{10, 2, 2, 5}",
            "9"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-2",
    "title": "groupSum6",
    "description": "Given an array of ints, is it possible to choose a group of some of the ints, beginning at the start index, such that the group sums to the given target? However, with the additional constraint that all 6\u0027s must be chosen. (No loops needed.) ",
    "examples": "groupSum6(0, {5, 6, 2}, 8) → true groupSum6(0, {5, 6, 2}, 9) → false groupSum6(0, {5, 6, 2}, 7) → false\n",
    "template": "public boolean groupSum6(int start, int[] nums, int target) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "start"
        },
        {
          "type": "int[]",
          "name": "nums"
        },
        {
          "type": "int",
          "name": "target"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "0",
            "{5, 6, 2}",
            "8"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{5, 6, 2}",
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{5, 6, 2}",
            "7"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{1}",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{9}",
            "1"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{3, 2, 4, 6}",
            "8"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{6, 2, 4, 3}",
            "8"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{5, 2, 4, 6}",
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{6, 2, 4, 5}",
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{3, 2, 4, 6}",
            "3"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{1, 6, 2, 6, 4}",
            "12"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{1, 6, 2, 6, 4}",
            "13"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{1, 6, 2, 6, 4}",
            "4"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{1, 6, 2, 6, 4}",
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{1, 6, 2, 6, 5}",
            "14"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{1, 6, 2, 6, 5}",
            "15"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{1, 6, 2, 6, 5}",
            "16"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-2",
    "title": "groupNoAdj",
    "description": "Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target with this additional constraint: If a value in the array is chosen to be in the group, the value immediately following it in the array must not be chosen. (No loops needed.) ",
    "examples": "groupNoAdj(0, {2, 5, 10, 4}, 12) → true groupNoAdj(0, {2, 5, 10, 4}, 14) → false groupNoAdj(0, {2, 5, 10, 4}, 7) → false\n",
    "template": "public boolean groupNoAdj(int start, int[] nums, int target) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "start"
        },
        {
          "type": "int[]",
          "name": "nums"
        },
        {
          "type": "int",
          "name": "target"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "0",
            "{2, 5, 10, 4}",
            "12"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{2, 5, 10, 4}",
            "14"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{2, 5, 10, 4}",
            "7"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{2, 5, 10, 4, 2}",
            "7"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{2, 5, 10, 4}",
            "9"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{10, 2, 2, 3, 3}",
            "15"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{10, 2, 2, 3, 3}",
            "7"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{1}",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{9}",
            "1"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{9}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{5, 10, 4, 1}",
            "11"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-2",
    "title": "groupSum5",
    "description": "Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target with these additional constraints: all multiples of 5 in the array must be included in the group. If the value immediately following a multiple of 5 is 1, it must not be chosen. (No loops needed.) ",
    "examples": "groupSum5(0, {2, 5, 10, 4}, 19) → true groupSum5(0, {2, 5, 10, 4}, 17) → true groupSum5(0, {2, 5, 10, 4}, 12) → false\n",
    "template": "public boolean groupSum5(int start, int[] nums, int target) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "start"
        },
        {
          "type": "int[]",
          "name": "nums"
        },
        {
          "type": "int",
          "name": "target"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "0",
            "{2, 5, 10, 4}",
            "19"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{2, 5, 10, 4}",
            "17"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{2, 5, 10, 4}",
            "12"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{2, 5, 4, 10}",
            "12"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{3, 5, 1}",
            "4"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{3, 5, 1}",
            "5"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{1, 3, 5}",
            "5"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{3, 5, 1}",
            "9"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{2, 5, 10, 4}",
            "7"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{2, 5, 10, 4}",
            "15"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{2, 5, 10, 4}",
            "11"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{1}",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{9}",
            "1"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{9}",
            "0"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{}",
            "0"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-2",
    "title": "groupSumClump",
    "description": "Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target, with this additional constraint: if there are numbers in the array that are adjacent and the identical value, they must either all be chosen, or none of them chosen. For example, with the array {1, 2, 2, 2, 5, 2}, either all three 2\u0027s in the middle must be chosen or not, all as a group. (one loop can be used to find the extent of the identical values). ",
    "examples": "groupSumClump(0, {2, 4, 8}, 10) → true groupSumClump(0, {1, 2, 4, 8, 1}, 14) → true groupSumClump(0, {2, 4, 4, 8}, 14) → false\n",
    "template": "public boolean groupSumClump(int start, int[] nums, int target) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int",
          "name": "start"
        },
        {
          "type": "int[]",
          "name": "nums"
        },
        {
          "type": "int",
          "name": "target"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "0",
            "{2, 4, 8}",
            "10"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{1, 2, 4, 8, 1}",
            "14"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{2, 4, 4, 8}",
            "14"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{8, 2, 2, 1}",
            "9"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{8, 2, 2, 1}",
            "11"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "0",
            "{1}",
            "1"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "0",
            "{9}",
            "1"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-2",
    "title": "splitArray",
    "description": "Given an array of ints, is it possible to divide the ints into two groups, so that the sums of the two groups are the same. Every int must be in one group or the other. Write a recursive helper method that takes whatever arguments you like, and make the initial call to your recursive helper from splitArray(). (No loops needed.) ",
    "examples": "splitArray(). (No loops needed.) splitArray({2, 2}) → true splitArray({2, 3}) → false splitArray({5, 2, 3}) → true\n",
    "template": "public boolean splitArray(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{2, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 3}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{5, 2, 3}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{5, 2, 2}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1, 1, 1, 1, 1, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 1, 1, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 5}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{5, 3, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2,2,10,10,1,1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1,2,2,10,10,1,1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1,2,3,10,10,1,1}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-2",
    "title": "splitOdd10",
    "description": "Given an array of ints, is it possible to divide the ints into two groups, so that the sum of one group is a multiple of 10, and the sum of the other group is odd. Every int must be in one group or the other. Write a recursive helper method that takes whatever arguments you like, and make the initial call to your recursive helper from splitOdd10(). (No loops needed.) ",
    "examples": "splitOdd10(). (No loops needed.) splitOdd10({5, 5, 5}) → true splitOdd10({5, 5, 6}) → false splitOdd10({5, 5, 6, 1}) → true\n",
    "template": "public boolean splitOdd10(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{5, 5, 5}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{5, 5, 6}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{5, 5, 6, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{6, 5, 5, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{6, 5, 5, 1, 10}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{6, 5, 5, 5, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{10, 7, 5, 5}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{10, 0, 5, 5}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{10, 7, 5, 5, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{10, 7, 5, 5, 1}"
          ],
          "expectedValue": "false"
        }
      ]
    }
  },
  {
    "groupName": "Recursion-2",
    "title": "split53",
    "description": "Given an array of ints, is it possible to divide the ints into two groups, so that the sum of the two groups is the same, with these constraints: all the values that are multiple of 5 must be in one group, and all the values that are a multiple of 3 (and not a multiple of 5) must be in the other. (No loops needed.) ",
    "examples": "split53({1,1}) → true split53({1, 1, 1}) → false split53({2, 4, 2}) → true\n",
    "template": "public boolean split53(int[] nums) {\n  \n}",
    "methodSignature": {
      "inArgList": [
        {
          "type": "int[]",
          "name": "nums"
        }
      ],
      "returnType": "boolean"
    },
    "taskTestDataContainer": {
      "taskTestDataList": [
        {
          "inData": [
            "{1,1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{1, 1, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 4, 2}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{2, 2, 2, 1}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{3, 3, 5, 1}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 5, 8}"
          ],
          "expectedValue": "false"
        },
        {
          "inData": [
            "{2, 4, 6}"
          ],
          "expectedValue": "true"
        },
        {
          "inData": [
            "{3, 5, 6, 10, 3, 3}"
          ],
          "expectedValue": "true"
        }
      ]
    }
  }
]